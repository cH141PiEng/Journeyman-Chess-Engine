(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 13.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[    209858,       5868]
NotebookOptionsPosition[    184079,       5490]
NotebookOutlinePosition[    184531,       5508]
CellTagsIndexPosition[    184488,       5505]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{

Cell[CellGroupData[{
Cell["The Journeyman Chess Engine", "Title",
 CellChangeTimes->{{3.8597317989212503`*^9, 
  3.859731812946732*^9}},ExpressionUUID->"68add65e-cd56-44a1-ab5e-\
b6e8555e9ccf"],

Cell["Jay Warendorff", "Text",
 CellChangeTimes->{{3.860255275060954*^9, 
  3.860255280237913*^9}},ExpressionUUID->"1753ab05-e552-4dbb-bfcc-\
e61e835b9a85"],

Cell["May 27 2022 20:01", "Text",
 CellChangeTimes->{{3.860255248694729*^9, 3.8602552703329983`*^9}, {
  3.860255846277343*^9, 3.860255850361425*^9}, {3.860256352785281*^9, 
  3.860256353624259*^9}, {3.8602772775199413`*^9, 3.860277281328906*^9}, {
  3.861484847083303*^9, 
  3.861484857560782*^9}},ExpressionUUID->"2a41ac94-1596-45c7-9897-\
60fbec7990be"],

Cell["\<\
The Journeyman chess engine is written in the C language in a single .c file \
which may be compiled in Visual Studio to make a .exe file for Windows. It is \
a full-featured engine, but relatively simple employing no advanced \
algorithms. Rather than using a transposition table, it uses a history table. \
It is mostly based on the Video Instruction Chess Engine up through video #82 \
at this page:\
\>", "Text",
 CellChangeTimes->{{3.859731931289741*^9, 3.8597322883100967`*^9}, {
   3.859732366671179*^9, 3.859732379551437*^9}, {3.859732557127331*^9, 
   3.8597325593574657`*^9}, {3.85973288042957*^9, 3.859732972731062*^9}, {
   3.859745286218308*^9, 3.859745371905643*^9}, {3.859761618961281*^9, 
   3.859761663843977*^9}, {3.859825596866749*^9, 3.859825613511889*^9}, {
   3.859825652326618*^9, 3.859825751308721*^9}, {3.859826406507193*^9, 
   3.859826408206656*^9}, 
   3.860255424792284*^9},ExpressionUUID->"cfe1bbba-1424-4947-9b20-\
291553ade1be"],

Cell["https://www.chessprogramming.org/Vice", "Text",ExpressionUUID->"0055e0fb-abc9-4009-a038-dd07907a5b5b"],

Cell["\<\
For simplicity, changes have been made to the code so that the board \
representation is an array of 64 integers instead of a 120 array of integers \
which seems a little more difficult to understand. This document is intended \
to explain how the Journeyman chess engine works.\
\>", "Text",
 CellChangeTimes->{{3.859731931289741*^9, 3.8597322883100967`*^9}, {
  3.859732366671179*^9, 3.859732379551437*^9}, {3.859732557127331*^9, 
  3.8597325593574657`*^9}, {3.85973288042957*^9, 3.859732972731062*^9}, {
  3.859745286218308*^9, 3.859745371905643*^9}, {3.859761618961281*^9, 
  3.859761663843977*^9}, {3.859825596866749*^9, 3.859825613511889*^9}, {
  3.859825652326618*^9, 3.859825751308721*^9}, {3.859826406507193*^9, 
  3.859826408206656*^9}, {3.8602554302752323`*^9, 
  3.860255434559586*^9}},ExpressionUUID->"02c10016-c601-4f91-865e-\
1befdb355207"],

Cell["\<\
Features include: Full support to play against from the Arena chess GUI and \
the capability to play against other chess engines in that GUI. Also \
implemented is the capability to set up a board position and play against the \
engine from that position. The engine implements the alpha-beta pruning \
algorithm together with move ordering to significantly increase the search \
depth over minimax for any fixed amount of time to search the chess tree for \
a given board position.\
\>", "Text",
 CellChangeTimes->{{3.8597329865904703`*^9, 3.8597329965272093`*^9}, {
  3.859738089487712*^9, 3.8597381732885637`*^9}, {3.859738316328123*^9, 
  3.859738383204204*^9}, {3.8597400744119053`*^9, 3.859740199477869*^9}, {
  3.860255112692327*^9, 3.860255113347741*^9}, {3.860273720258271*^9, 
  3.860273906384756*^9}, {3.860275504407703*^9, 
  3.8602755167084303`*^9}},ExpressionUUID->"76cf1f93-5619-4684-80b9-\
9bb41b6fe571"],

Cell["\<\
The rules of chess as well as the fundamentals of the C are assumed to be \
known by our readers. \
\>", "Text",
 CellChangeTimes->{{3.859743512086835*^9, 3.8597435365697613`*^9}, {
  3.859745377844817*^9, 3.859745412321138*^9}, {3.859761704099881*^9, 
  3.859761727842207*^9}},ExpressionUUID->"ea8f2cc8-dcb8-4c21-b24c-\
365a66e4e5ec"],

Cell[CellGroupData[{

Cell["Overview", "Section",
 CellChangeTimes->{{3.8597615976035547`*^9, 
  3.859761601665564*^9}},ExpressionUUID->"05a33c8f-42cb-4085-91ae-\
1e3f46174478"],

Cell["Coming", "Text",
 CellChangeTimes->{{3.860255088416457*^9, 
  3.860255091201387*^9}},ExpressionUUID->"7d59de6a-2206-47e3-8bdd-\
59cd49a7e330"]
}, Open  ]],

Cell[CellGroupData[{

Cell["History", "Section",
 CellChangeTimes->{{3.86025711254084*^9, 
  3.860257114143869*^9}},ExpressionUUID->"926d0580-5914-465a-8d4e-\
eaf7d189e9cd"],

Cell["Version 1.0 - 22 Feb 2022", "Text",
 CellChangeTimes->{{3.860257117465878*^9, 
  3.860257134182582*^9}},ExpressionUUID->"a9300752-47aa-451e-849a-\
49e49224424d"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Strength", "Section",
 CellChangeTimes->{{3.860275341165578*^9, 
  3.8602753439434433`*^9}},ExpressionUUID->"77661812-1b6f-40d5-a28c-\
f6731f7a784b"],

Cell["\<\
Version 1.0 seems to be close to 1700 elo in 2\[CloseCurlyQuote]+1\
\[CloseCurlyDoubleQuote] blitz using the Perfect 2010 (up to 12 half moves) \
opening book that comes with Arena.\
\>", "Text",
 CellChangeTimes->{{3.860275351532765*^9, 3.860275413577999*^9}, {
  3.860276690107004*^9, 3.860276709407538*^9}, {3.8602767580375566`*^9, 
  3.860276792576824*^9}},ExpressionUUID->"5381385f-b79f-481a-aa7d-\
3594da5b42cb"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Obtaining the Source Code and Executable for Version 1.0", "Section",
 CellChangeTimes->{{3.860255727410068*^9, 3.8602557632428293`*^9}, 
   3.860255798961471*^9, {3.86025704557463*^9, 
   3.860257050527245*^9}},ExpressionUUID->"21542e4b-72a9-42f3-8da1-\
d958097c6e8e"],

Cell["They may be downloaded here:", "Text",
 CellChangeTimes->{{3.8602557724445553`*^9, 
  3.860255786156389*^9}},ExpressionUUID->"26df83a3-cda7-4f1e-8c3b-\
4972c4026bec"],

Cell["\<\
https://github.com/cH141PiEng/Journeyman-Chess-Engine/releases/tag/v1.0\
\>", "Text",
 CellChangeTimes->{
  3.8602557690056*^9},ExpressionUUID->"1b97f0bb-2666-45a4-bfa6-7b4618e5cf64"]
}, Open  ]],

Cell[CellGroupData[{

Cell["GUI to Run the Engine In", "Section",
 CellChangeTimes->{{3.8602567403058662`*^9, 
  3.860256756838316*^9}},ExpressionUUID->"629582e1-f628-4e68-908f-\
2a5fc56f0100"],

Cell["You may get the Windows version here", "Text",
 CellChangeTimes->{{3.860256774372039*^9, 
  3.8602567885368843`*^9}},ExpressionUUID->"06210a81-bd1b-453c-acc7-\
9b75da36b3b7"],

Cell["http://www.playwitharena.de/", "Text",
 CellChangeTimes->{
  3.860256763331417*^9},ExpressionUUID->"5a9d6a2e-fd7d-4f7a-bf70-\
142aa8aa28c3"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Board Representation", "Section",
 CellChangeTimes->{{3.859739714004023*^9, 
  3.859739722088784*^9}},ExpressionUUID->"a3d16acf-308a-4120-9b66-\
b2979cce2bfc"],

Cell["\<\
For the squares of the board a1 is represented by 0, b1 by 1,..., a8 by 56, \
... h8 by 63. We also make use of no_sq = 64.\
\>", "Text",
 CellChangeTimes->{{3.859739733523555*^9, 3.859739889427703*^9}, {
  3.859739924746973*^9, 
  3.85973993699597*^9}},ExpressionUUID->"651db410-1587-42f6-81ae-\
a045316a0d95"],

Cell["So we define the following enum:", "Text",
 CellChangeTimes->{{3.859739896043895*^9, 
  3.8597399121254673`*^9}},ExpressionUUID->"b6fc4efa-9101-4bdb-a0e2-\
ee5e87eccafa"],

Cell["\<\
enum {
    a1 = 0, b1, c1, d1, e1, f1, g1, h1,
    a2 = 8, b2, c2, d2, e2, f2, g2, h2,
    a3 = 16, b3, c3, d3, e3, f3, g3, h3,
    a4 = 24, b4, c4, d4, e4, f4, g4, h4,
    a5 = 32, b5, c5, d5, e5, f5, g5, h5,
    a6 = 40, b6, c6, d6, e6, f6, g6, h6,
    a7 = 48, b7, c7, d7, e7, f7, g7, h7,
    a8 = 56, b8, c8, d8, e8, f8, g8, h8, no_sq
};\
\>", "Text",
 CellChangeTimes->{
  3.859739949848262*^9},ExpressionUUID->"fd95d833-95af-4249-b03e-\
24730f3208af"],

Cell["\<\
We also use an enum to represent the pieces, with the empty piece being 0:\
\>", "Text",
 CellChangeTimes->{{3.859739976996768*^9, 
  3.859740034641481*^9}},ExpressionUUID->"471153b1-4585-481d-9211-\
e6b3accb0520"],

Cell["enum { e = 0, P, N, B, R, Q, K, p, n, b, r, q, k };", "Text",
 CellChangeTimes->{{3.859740047517994*^9, 
  3.859740048857575*^9}},ExpressionUUID->"ff8e303d-5002-4d50-987c-\
0eba128a6b0f"],

Cell["We use enums for the files, ranks and colors:", "Text",
 CellChangeTimes->{{3.8597403385064583`*^9, 
  3.859740359419449*^9}},ExpressionUUID->"88821641-8414-4003-8923-\
fd60a0635d3e"],

Cell["\<\
enum { FILE_A, FILE_B, FILE_C, FILE_D, FILE_E, FILE_F, FILE_G, FILE_H, \
FILE_NONE };
enum { RANK_1, RANK_2, RANK_3, RANK_4, RANK_5, RANK_6, RANK_7, RANK_8, \
RANK_NONE };

enum { WHITE, BLACK, BOTH };\
\>", "Text",
 CellChangeTimes->{
  3.8597403640116577`*^9},ExpressionUUID->"21880b04-ce70-4749-84a1-\
9a8b6d89a1aa"],

Cell["We also define:", "Text",
 CellChangeTimes->{{3.859740431212063*^9, 
  3.859740439323883*^9}},ExpressionUUID->"e462c5d3-3691-472c-b8b0-\
04b200438eb3"],

Cell["\<\
#define FALSE 0
#define TRUE  1

#define BRD_SQ_NUM 64\
\>", "Text",
 CellChangeTimes->{
  3.8597404433989697`*^9, {3.859741076632669*^9, 
   3.859741077746873*^9}},ExpressionUUID->"8610c333-fb21-41db-a01d-\
d2a38810b054"],

Cell["\<\
For pawns we will be using 64 bit integers to store the positions of the \
white pawns, the black pawns and both colors of pawns. So for convenience we \
define U64:\
\>", "Text",
 CellChangeTimes->{{3.859740893742443*^9, 3.859741033482046*^9}, {
  3.86025621705275*^9, 
  3.8602562207023363`*^9}},ExpressionUUID->"1548fa4b-b83b-4342-888e-\
b1f79937535f"],

Cell["typedef unsigned long long U64;", "Text",
 CellChangeTimes->{{3.859740893742443*^9, 3.859741033482046*^9}, {
  3.86025621705275*^9, 
  3.8602562237355433`*^9}},ExpressionUUID->"424b2180-3d5a-486e-a4eb-\
676a0b964f57"],

Cell["\<\
This will make the evaluation of such things as passed and doubled pawns \
easier and more efficient.\
\>", "Text",
 CellChangeTimes->{{3.859741618065384*^9, 3.85974167011971*^9}, {
  3.86025622858941*^9, 
  3.860256229386217*^9}},ExpressionUUID->"491d58df-142b-45ee-a5a1-\
21f17387809c"],

Cell["\<\
We need to be able to set up a position on the board. First we need a board \
structure.\
\>", "Text",
 CellChangeTimes->{{3.8597400625836077`*^9, 3.859740065452503*^9}, {
  3.859740208728801*^9, 3.859740216632494*^9}, {3.8597406163067102`*^9, 
  3.859740647837061*^9}},ExpressionUUID->"c2a21a82-f9c5-4924-9199-\
b5e4aa46bdce"],

Cell["\<\
typedef struct {

    int pieces[BRD_SQ_NUM]; //Pieces corresponding to each squares
    U64 pawns[3]; //Pawn bitboards - white, black, both, a bit is set to a 1 \
if the corresponding color on that square has a pawn and 0 otherwise
                                  // 00000000 11111111 00000000 00000000 \
00000000 00000000 00000000 00000000 the white pawn bitboard for the standard \
startposition.

    int KingSq[2]; //King square for white and black

    int side;//Current side to move
    int enPas;//the enpassant square if there is one, otherwise set to no_sq
    int fiftyMove;//Uses half moves so when 100 game is drawn

    int ply;//How many half moves we are into the current search
    int hisPly;//How many half moves in total game so far - needed for \
looking back and determining repetitions

    int castlePerm;//stores castle permissions

    U64 posKey;//A unique key/number generated for each position (move)
    //representing the position on the board, used to detect using
    //the history array if we have repetitions in the position
    //posKey idea introduced in video 11

    int pceNum[13];//number of pieces on the board indexed by piece type
    int bigPce[2];//number of all pieces except pawns
    int majPce[2];//number of rooks and queens for white and black
    int minPce[2];//number of knights and bishops for white and black 
    int material[2];//material value for white and black

} S_BOARD;\
\>", "Text",
 CellChangeTimes->{{3.859740751292242*^9, 3.859740768778893*^9}, {
   3.859741209895049*^9, 3.85974126348566*^9}, {3.8597414293820267`*^9, 
   3.859741548560388*^9}, 3.859741712203042*^9, {3.859741765926252*^9, 
   3.8597418105757523`*^9}, {3.859741853137536*^9, 3.859741853841516*^9}, {
   3.859742058873459*^9, 3.85974207164543*^9}, 
   3.8597422327571173`*^9},ExpressionUUID->"1864e459-2edd-48c2-94ec-\
ee9733ef38ed"],

Cell["\<\
For castling permissions we introduce the following for white kingside \
castling permissions, white queenside castling permissions, etc. The castling \
permissions will be represented by 4 bits. It is easier to store permissions \
in a single integer.\
\>", "Text",
 CellChangeTimes->{{3.859743403854822*^9, 3.859743485410791*^9}, {
  3.859743690872859*^9, 3.859743716742256*^9}, {3.859743958800757*^9, 
  3.859743984344314*^9}, {3.8602562590646143`*^9, 
  3.860256262896803*^9}},ExpressionUUID->"efee58b3-aa1b-43f7-b0fa-\
879b542f0c84"],

Cell["enum { WKCA = 1, WQCA = 2, BKCA = 4, BQCA = 8 };", "Text",
 CellChangeTimes->{
  3.859743307770784*^9},ExpressionUUID->"55881ed5-f810-4583-87e7-\
25d652699237"],

Cell["\<\
   binary    decimal

   0001       1  white king can castle to the king side
   0010       2  white king can castle to the queen side
   0100       4  black king can castle to the king side
   1000       8  black king can castle to the queen side

   examples:

   1111       both sides an castle both directions
   1001       black king => queen side
                    white king => king side\
\>", "Text",
 CellChangeTimes->{{3.859743766857142*^9, 3.859743789255228*^9}, {
  3.85974404460924*^9, 
  3.8597440827083*^9}},ExpressionUUID->"2ce14ecc-f1da-453b-88d2-a0d9ca09ad07"],

Cell["and we add this to the board structure", "Text",
 CellChangeTimes->{{3.8597436347862587`*^9, 
  3.859743649078947*^9}},ExpressionUUID->"f2edca4a-6988-44b3-82df-\
05d6897f7174"],

Cell["int castlePerm;", "Text",
 CellChangeTimes->{
  3.859743653225628*^9},ExpressionUUID->"233d1292-c3b0-4645-a4f1-\
46576e3f7d19"],

Cell["\<\
Next we will look at how we can store the history of the game to undo moves \
as needed and detect a threefold repetition.\
\>", "Text",
 CellChangeTimes->{
  3.859744156206841*^9},ExpressionUUID->"4fec85f3-926a-41b4-9404-\
7e8acb5eb5e2"],

Cell["Max # of half moves expected in a game:", "Text",
 CellChangeTimes->{{3.859744212326324*^9, 
  3.859744215409026*^9}},ExpressionUUID->"116af054-d2a4-49ba-8c08-\
8b933a608f1f"],

Cell["#define MAXGAMEMOVES 2048", "Text",
 CellChangeTimes->{{3.859744194548257*^9, 
  3.859744218424786*^9}},ExpressionUUID->"d991bbac-14e8-4c98-ad1a-\
5244d964aa6f"],

Cell["\<\
We need to define a structure that contains the information that will allow \
us to undo a move (will will be storing a move as an integer which will be \
covered later)\
\>", "Text",
 CellChangeTimes->{{3.859744359502861*^9, 3.859744382073818*^9}, {
  3.859744443946555*^9, 
  3.8597445150178003`*^9}},ExpressionUUID->"4e608162-03ac-4c4a-b8b4-\
31ea291f869a"],

Cell["\<\
typedef struct {

    int move;
    int castlePerm; // before that move was played
    int enPas;
    int fiftyMove;
    U64 posKey;

} S_UNDO;\
\>", "Text",
 CellChangeTimes->{
  3.8597444232536488`*^9, {3.859744648493175*^9, 
   3.859744661878767*^9}},ExpressionUUID->"22d87535-f1a1-474c-b055-\
c4c1e7a27cfe"],

Cell["\<\
We need to create an array inside our board structure of undo information. \
Every time a move is made on the board, we will store in whatever move # we \
are at in the game, the move about to be made, and the values of the other \
items before making the move.\
\>", "Text",
 CellChangeTimes->{{3.859744706298451*^9, 3.859744741804062*^9}, {
  3.859744802155653*^9, 3.859744802591539*^9}, {3.859744898951923*^9, 
  3.8597450088988323`*^9}},ExpressionUUID->"db2a18ea-7328-485d-b80f-\
7da8f90cce76"],

Cell["S_UNDO history[MAXGAMEMOVES];", "Text",
 CellChangeTimes->{
  3.859744799725193*^9},ExpressionUUID->"91a1a6b4-7b7f-4826-9f30-\
664385c431ad"],

Cell["\<\
For later use. Returns the square #, given the file and rank:\
\>", "Text",
 CellChangeTimes->{{3.859745765456766*^9, 3.859745783523077*^9}, 
   3.860256290085503*^9},ExpressionUUID->"7b235dbd-1a18-4584-90b5-\
4a67f8ff34bb"],

Cell["#define FR2SQ(f, r) ( (f) + ( (r) * 8 ) )", "Text",
 CellChangeTimes->{{3.859745765456766*^9, 3.859745783523077*^9}, 
   3.860256292520371*^9},ExpressionUUID->"564c2d8f-178a-4bf6-8c42-\
f67627479fda"],

Cell["\<\
All the things we want to set up in the program before it starts running will \
be in the AllInit() function.\
\>", "Text",
 CellChangeTimes->{{3.8597454672408237`*^9, 
  3.859745541596217*^9}},ExpressionUUID->"3c65d667-bb1e-4549-9cf2-\
1f1b7614eb59"],

Cell["\<\
Suppose we want to generate all the moves for white - we can use a piece \
list. We add this to the board structure (13 - since there are 13 piece types \
and up to 10 of each):\
\>", "Text",
 CellChangeTimes->{{3.8597489662959423`*^9, 3.8597490015764847`*^9}, {
  3.859749315525477*^9, 
  3.859749395732564*^9}},ExpressionUUID->"ddab1ea6-0898-4374-9145-\
5ee9829d63b7"],

Cell["int pList[13][10];", "Text",
 CellChangeTimes->{{3.859749336215302*^9, 
  3.8597493367604713`*^9}},ExpressionUUID->"43a04fbd-1089-4f48-a854-\
cd345bbf998d"],

Cell["At first all the values are set to no_sq.", "Text",
 CellChangeTimes->{{3.859753467088475*^9, 3.859753545521852*^9}, {
   3.8597536341341133`*^9, 3.859753770972458*^9}, {3.859753814285469*^9, 
   3.859753831312297*^9}, {3.859753928331992*^9, 3.859753951427397*^9}, {
   3.85975406823568*^9, 3.859754097055192*^9}, 
   3.8602563176534452`*^9},ExpressionUUID->"c97a2b0c-e24e-40f3-b495-\
e496ad75e824"],

Cell["\<\
Example - add White knights at E1and D4 - pList[N][0] = E1; pList[N][1] = D4; \
We would loop through pList[N][i] until the value returned is no_sq. So we do \
not need to loop through all the squares on the board.\
\>", "Text",
 CellChangeTimes->{{3.859753467088475*^9, 3.859753545521852*^9}, {
   3.8597536341341133`*^9, 3.859753770972458*^9}, {3.859753814285469*^9, 
   3.859753831312297*^9}, {3.859753928331992*^9, 3.859753951427397*^9}, {
   3.85975406823568*^9, 3.859754097055192*^9}, 
   3.860256320396812*^9},ExpressionUUID->"9d540e1b-dcd2-4eb5-a567-\
b486aa13a59b"],

Cell["Makes the engine faster during move generation.", "Text",
 CellChangeTimes->{{3.859753467088475*^9, 3.859753545521852*^9}, {
  3.8597536341341133`*^9, 3.859753770972458*^9}, {3.859753814285469*^9, 
  3.859753831312297*^9}, {3.859753928331992*^9, 3.859753951427397*^9}, {
  3.85975406823568*^9, 
  3.859754097055192*^9}},ExpressionUUID->"fa3185aa-1f2a-46c4-a8c0-\
e4b8bfc26482"]
}, Closed]],

Cell[CellGroupData[{

Cell["Bitboard Utilities", "Section",
 CellChangeTimes->{{3.859758112114533*^9, 
  3.859758121994524*^9}},ExpressionUUID->"007dd17b-4966-4b00-a9e6-\
9d2b36b2e326"],

Cell["\<\
Some functions for working with bitboards:

int Lsb(const U64 bb) {
    unsigned long index = -1;
    _BitScanForward64(&index, bb);
    return index;
}

// Returns the index of the least significant bit and unsets it
int PopBit(U64* bb) {

    int lsb = Lsb(*bb);
    *bb &= (*bb - 1);

    return lsb;
}

#define CountBits(bb) ((int) (__popcnt64(bb)))\
\>", "Text",
 CellChangeTimes->{{3.8597545176957903`*^9, 
  3.859754558999106*^9}},ExpressionUUID->"274a2cbd-3b26-4fdc-9680-\
21e7ba6fe606"],

Cell["\<\
We need a way to set and clear bits on a bitboard.

U64 SetMask[64];
U64 ClearMask[64];

void InitBitMasks() {
    int index = 0;

    for (index = 0; index < 64; index++) {
        SetMask[index] = 0ULL;
        ClearMask[index] = 0ULL;
    }

    for (index = 0; index < 64; index++) {
        SetMask[index] |= (1ULL << index);
        ClearMask[index] = ~SetMask[index];
    }
}

#define CLRBIT(bb,sq) ((bb) &= ClearMask[(sq)])
#define SETBIT(bb,sq) ((bb) |= SetMask[(sq)])\
\>", "Text",
 CellChangeTimes->{{3.859754687202053*^9, 3.859754717795442*^9}, {
  3.85975475338461*^9, 3.85975475435128*^9}, {3.859754901828415*^9, 
  3.859754902927878*^9}},ExpressionUUID->"09c535e2-8769-4b8f-9dc4-\
e57e1d8ba5c6"],

Cell["And we put InitBitMasks() into AllInit().", "Text",
 CellChangeTimes->{{3.85975476959581*^9, 3.859754780006493*^9}, {
  3.859754820568622*^9, 
  3.859754822791641*^9}},ExpressionUUID->"5dd29900-2178-4794-a5c6-\
e2a395d1f214"]
}, Closed]],

Cell[CellGroupData[{

Cell["Position Key", "Section",
 CellChangeTimes->{{3.8600062801446*^9, 
  3.8600062866066017`*^9}},ExpressionUUID->"01de79f0-ee2b-4f79-9cdb-\
84afbb338bc7"],

Cell["\<\
A unique key/number generated for each position (move) representing the \
position on the board, used to detect using the history array if we have \
repetitions in the position. Introduced in video 11. In the S_BOARD structure:\
\>", "Text",
 CellChangeTimes->{{3.860012235907145*^9, 3.8600122700034857`*^9}, {
  3.860012301740951*^9, 
  3.860012318042634*^9}},ExpressionUUID->"a76a72f2-6837-4fe0-aaa6-\
4e9cfa9b6bc6"],

Cell["U64 posKey;", "CodeText",
 CellChangeTimes->{{3.860012221750432*^9, 3.8600122331509857`*^9}, 
   3.860012275258546*^9},ExpressionUUID->"6c9637df-0a60-4fcc-8c61-\
66c05390565e"],

Cell["We need a way to generate a key for a chess board position.", "Text",
 CellChangeTimes->{{3.860012377738493*^9, 
  3.860012407391922*^9}},ExpressionUUID->"13d919eb-0e9e-4117-96d2-\
74aba2575010"],

Cell["\<\
U64 PieceKeys[13][64]; //Stores a random 64 bit number which states that that \
type of element is present on that sq number 
U64 SideKey; //Stores a random number if it is the turn of white in the game 
U64 CastleKeys[16]; //Stores 64 random numbers which represent each possible \
type of castle positions which are 0 to 15\
\>", "CodeText",
 CellChangeTimes->{{3.8600130345195827`*^9, 
  3.8600130563978863`*^9}},ExpressionUUID->"b4d0c87a-553e-48f7-aa59-\
e9e5e469a4b7"],

Cell["\<\
Include stdlib.h to use rand() which generates a 15 bit random #
Fills 64 bits with random #s\
\>", "Text",
 CellChangeTimes->{{3.860013127409931*^9, 
  3.860013149425951*^9}},ExpressionUUID->"b6278e5b-9447-4916-8478-\
d5fb9d757d29"],

Cell["\<\
#define RAND_64 \t((U64)rand() | \\
\t\t\t\t\t(U64)rand() << 15 | \\
\t\t\t\t\t(U64)rand() << 30 | \\
\t\t\t\t\t(U64)rand() << 45 | \\
\t\t\t\t\t((U64)rand() & 0xf) << 60 )\
\>", "CodeText",
 CellChangeTimes->{{3.860013127409931*^9, 
  3.8600131453475723`*^9}},ExpressionUUID->"c74477fd-461e-4981-adc7-\
7b76fde27b6f"],

Cell["\<\
This is a modified rand function which generates 64 bit random numbers for \
our poskey values.\
\>", "Text",
 CellChangeTimes->{{3.860013127409931*^9, 3.860013136357479*^9}, {
   3.86001317022497*^9, 3.8600131799398212`*^9}, 
   3.860013434245579*^9},ExpressionUUID->"b72aacdc-4f07-40dc-a481-\
66615ccb511e"],

Cell["Fills the variables with random numbers:", "Text",
 CellChangeTimes->{{3.860013437953136*^9, 
  3.860013455250342*^9}},ExpressionUUID->"3c54fbf9-6ddc-42e2-b2cc-\
045a67a09370"],

Cell["\<\
void InitHashKeys() {

    int index = 0;
    int index2 = 0;
    for (index = 0; index < 13; ++index) {
        for (index2 = 0; index2 < 64; ++index2) {
            PieceKeys[index][index2] = RAND_64;
        }
    }
    SideKey = RAND_64;
    for (index = 0; index < 16; ++index) {
        CastleKeys[index] = RAND_64;
    }
}\
\>", "CodeText",
 CellChangeTimes->{{3.8600134085985603`*^9, 
  3.860013416448209*^9}},ExpressionUUID->"54be1d98-79e3-424f-85e0-\
8e2b37622151"],

Cell["Put InitHashKeys() into the AllInit() function.", "Text",
 CellChangeTimes->{{3.860013513914918*^9, 
  3.8600135349994593`*^9}},ExpressionUUID->"8093f356-28b0-4ecc-8f7d-\
b12c7e750487"],

Cell["\<\
U64 GeneratePosKey(const S_BOARD* pos) {

    int sq = 0;
    U64 finalKey = 0;
    int piece = e;

    // pieces
    for (sq = 0; sq < BRD_SQ_NUM; ++sq) {
        piece = pos->pieces[sq];
        if (piece != no_sq && piece != e) {
            finalKey ^= PieceKeys[piece][sq];
        }
    }

    if (pos->side == WHITE) {
        finalKey ^= SideKey;
    }

    if (pos->enPas != no_sq) {
        finalKey ^= PieceKeys[e][pos->enPas];
    }

    finalKey ^= CastleKeys[pos->castlePerm];

    return finalKey;
}\
\>", "CodeText",
 CellChangeTimes->{
  3.860013619763192*^9},ExpressionUUID->"47811b36-59e4-49b8-85b7-\
9cf5db18d31b"]
}, Closed]],

Cell[CellGroupData[{

Cell["Setup a Position, FEN notation", "Section",
 CellChangeTimes->{{3.85975809211514*^9, 3.8597580990680723`*^9}, {
  3.860243634904414*^9, 3.860243655106667*^9}, {3.8602437391776*^9, 
  3.860243741858282*^9}},ExpressionUUID->"099baa15-68c2-4630-97a5-\
50d4978245ef"],

Cell["\<\
Before defining the function for setting up a board, we first need one to \
reset the board - removes all the pieces from the board and all the values \
inside the S_Board structure to 0.\
\>", "Text",
 CellChangeTimes->{{3.859755039557467*^9, 3.859755086451764*^9}, {
  3.859755171035276*^9, 
  3.859755221800849*^9}},ExpressionUUID->"d3269187-2ded-4d78-a9a9-\
a9f7df0b4eb2"],

Cell["\<\
void ResetBoard(S_BOARD* pos) {

    int index = 0;

    for (index = 0; index < 64; ++index) {
        pos->pieces[index] = e;
    }

    for (index = 0; index < 2; ++index) {
        pos->bigPce[index] = 0;
        pos->majPce[index] = 0;
        pos->minPce[index] = 0;
        pos->material[index] = 0;
    }

    for (index = 0; index < 3; ++index) {
        pos->pawns[index] = 0ULL;
    }

    for (index = 0; index < 13; ++index) {
        pos->pceNum[index] = 0;
    }

    pos->KingSq[WHITE] = pos->KingSq[BLACK] = no_sq;

    pos->side = BOTH;
    pos->enPas = no_sq;
    pos->fiftyMove = 0;

    pos->ply = 0;
    pos->hisPly = 0;

    pos->castlePerm = 0;

    pos->posKey = 0ULL;

}\
\>", "Text",
 CellChangeTimes->{
  3.859755136148719*^9},ExpressionUUID->"8edd3dc1-5a60-49bf-bfa3-\
4c0473fc0a7c"],

Cell["We will get into setting up a position on the board.", "Text",
 CellChangeTimes->{{3.8597553703622303`*^9, 
  3.859755391760811*^9}},ExpressionUUID->"419a1c84-eaf2-4e46-b734-\
329b64ea2eba"],

Cell["\<\
https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation\
\>", "Text",
 CellChangeTimes->{
  3.85975532879842*^9},ExpressionUUID->"8b66e3f0-4604-4fea-9081-2da541ae3d7c"],

Cell["\<\
#define START_FEN  \
\[OpenCurlyDoubleQuote]rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 \
1\[CloseCurlyDoubleQuote]\
\>", "Text",
 CellChangeTimes->{
  3.859755446663226*^9},ExpressionUUID->"aa5516ec-298b-42e0-8bb5-\
21771bac0b63"],

Cell["\<\
char PceChar[] = \
\[OpenCurlyDoubleQuote].PNBRQKpnbrqk\[CloseCurlyDoubleQuote];
char SideChar[] = \[OpenCurlyDoubleQuote]wb-\[OpenCurlyDoubleQuote];
char RankChar[] = \[OpenCurlyDoubleQuote]12345678\[CloseCurlyDoubleQuote];
char FileChar[] = \[OpenCurlyDoubleQuote]abcdefgh\[CloseCurlyDoubleQuote];\
\>", "Text",
 CellChangeTimes->{
  3.859758812131909*^9},ExpressionUUID->"25988fd9-7fa8-445b-89b0-\
f14813bcbf1c"],

Cell["\<\
#define IsBQ(p) (PieceBishopQueen[(p)])
#define IsRQ(p) (PieceRookQueen[(p)])
#define IsKn(p) (PieceKnight[(p)])
#define IsKi(p) (PieceKing[(p)])\
\>", "Text",
 CellChangeTimes->{
  3.8597588583660507`*^9},ExpressionUUID->"8f45b66b-c68a-4c03-bc65-\
894e43ca5abe"],

Cell["\<\
This function takes in a FEN notation character array, and a pointer to \
S_BOARD structure

int ParseFen(char* fen, S_BOARD* pos) {

    int  rank = RANK_8;
    int  file = FILE_A;
    int  piece = 0;
    int  count = 0;
    int  i = 0;
    int  sq = 0;

    ResetBoard(pos);

    while ((rank >= RANK_1) && *fen) {
        count = 1;
        switch (*fen) {
        case \[OpenCurlyQuote]p\[CloseCurlyQuote]: piece = p; break;
        case \[OpenCurlyQuote]r\[CloseCurlyQuote]: piece = r; break;
        case \[OpenCurlyQuote]n\[CloseCurlyQuote]: piece = n; break;
        case \[OpenCurlyQuote]b\[CloseCurlyQuote]: piece = b; break;
        case \[OpenCurlyQuote]k\[CloseCurlyQuote]: piece = k; break;
        case \[OpenCurlyQuote]q\[CloseCurlyQuote]: piece = q; break;
        case \[OpenCurlyQuote]P\[CloseCurlyQuote]: piece = P; break;
        case \[OpenCurlyQuote]R\[CloseCurlyQuote]: piece = R; break;
        case \[OpenCurlyQuote]N\[CloseCurlyQuote]: piece = N; break;
        case \[OpenCurlyQuote]B\[CloseCurlyQuote]: piece = B; break;
        case \[OpenCurlyQuote]K\[CloseCurlyQuote]: piece = K; break;
        case \[OpenCurlyQuote]Q\[CloseCurlyQuote]: piece = Q; break;

        case \[OpenCurlyQuote]1\[CloseCurlyQuote]:
        case \[OpenCurlyQuote]2\[CloseCurlyQuote]:
        case \[OpenCurlyQuote]3\[CloseCurlyQuote]:
        case \[OpenCurlyQuote]4\[CloseCurlyQuote]:
        case \[OpenCurlyQuote]5\[CloseCurlyQuote]:
        case \[OpenCurlyQuote]6\[CloseCurlyQuote]:
        case \[OpenCurlyQuote]7\[CloseCurlyQuote]:
        case \[OpenCurlyQuote]8\[CloseCurlyQuote]:
            piece = e;
            count = *fen - \[OpenCurlyQuote]0\[CloseCurlyQuote];
            break;

        case \[OpenCurlyQuote]/\[CloseCurlyQuote]:
        case \[OpenCurlyQuote] \[OpenCurlyQuote]:
            rank--;
            file = FILE_A;
            fen++;
            continue;

        default:
            printf(\[OpenCurlyDoubleQuote]FEN error \\n\
\[CloseCurlyDoubleQuote]);
            return -1;
        }

        for (i = 0; i < count; i++) {
            sq = rank * 8 + file;
            if (piece != e) {
                pos->pieces[sq] = piece;
            }
            file++;
        }
        fen++;
    }

    pos->side = (*fen == \[OpenCurlyQuote]w\[CloseCurlyQuote]) ? WHITE : BLACK;
    fen += 2;

    for (i = 0; i < 4; i++) {
        if (*fen == \[OpenCurlyQuote] \[OpenCurlyQuote]) {
            break;
        }
        switch (*fen) {
        case \[OpenCurlyQuote]K\[CloseCurlyQuote]: pos->castlePerm |= WKCA; \
break;
        case \[OpenCurlyQuote]Q\[CloseCurlyQuote]: pos->castlePerm |= WQCA; \
break;
        case \[OpenCurlyQuote]k\[CloseCurlyQuote]: pos->castlePerm |= BKCA; \
break;
        case \[OpenCurlyQuote]q\[CloseCurlyQuote]: pos->castlePerm |= BQCA; \
break;
        default:\t     break;
        }
        fen++;
    }
    fen++;

    if (*fen != \[OpenCurlyQuote]-\[OpenCurlyQuote]) {
        file = fen[0] - \[OpenCurlyQuote]a\[CloseCurlyQuote];
        rank = fen[1] - \[OpenCurlyQuote]1\[CloseCurlyQuote];

        pos->enPas = FR2SQ(file, rank);
    }

    pos->posKey = GeneratePosKey(pos);

    UpdateListsMaterial(pos);

    return 0;
}\
\>", "Text",
 CellChangeTimes->{
  3.859755562813656*^9, {3.859758806966765*^9, 
   3.859758808260559*^9}},ExpressionUUID->"312f9d45-cf8d-4914-8fe6-\
e27f23195512"]
}, Closed]],

Cell[CellGroupData[{

Cell["Printing a Board to the Screen", "Section",
 CellChangeTimes->{
  3.8602437237818947`*^9},ExpressionUUID->"7142e7ba-2d53-47ad-9bda-\
73643e4981eb"],

Cell["Prints the board when it has been set up by in FEN notation", "Text",
 CellChangeTimes->{
  3.859756039563389*^9, {3.860241057441917*^9, 
   3.860241061766905*^9}},ExpressionUUID->"30666dfb-6699-4323-ab02-\
366209cc39d8"],

Cell["\<\
void PrintBoard(const S_BOARD* pos) {

    int sq, file, rank, piece;

    printf(\"\\nGame Board:\\n\\n\");

    for (rank = RANK_8; rank >= RANK_1; rank--) {
        printf(\"%d  \", rank + 1);
        for (file = FILE_A; file <= FILE_H; file++) {
            sq = FR2SQ(file, rank);
            piece = pos->pieces[sq];
            printf(\"%3c\", PceChar[piece]);
        }
        printf(\"\\n\");
    }

    printf(\"\\n   \");
    for (file = FILE_A; file <= FILE_H; file++) {
        printf(\"%3c\", 'a' + file);
    }
    printf(\"\\n\");
    printf(\"side:%c\\n\", SideChar[pos->side]);
    printf(\"enPas:%d\\n\", pos->enPas);
    printf(\"castle:%c%c%c%c\\n\",
        pos->castlePerm & WKCA ? 'K' : '-',
        pos->castlePerm & WQCA ? 'Q' : '-',
        pos->castlePerm & BKCA ? 'k' : '-',
        pos->castlePerm & BQCA ? 'q' : '-'
    );
    printf(\"PosKey:%llX\\n\", pos->posKey);
}\
\>", "Text",
 CellChangeTimes->{
  3.859756039563389*^9, {3.860241057441917*^9, 
   3.860241057613288*^9}},ExpressionUUID->"e9cf66e0-9cdd-425d-aebb-\
b096be5dc5d8"]
}, Closed]],

Cell[CellGroupData[{

Cell["Piece Lists", "Section",
 CellChangeTimes->{{3.8602437969459887`*^9, 
  3.860243800919055*^9}},ExpressionUUID->"f54ba241-0067-4000-83ae-\
71637fc92a96"],

Cell["\<\
int PieceBig[13] = { FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, \
TRUE, TRUE, TRUE, TRUE };
int PieceMaj[13] = { FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, \
FALSE, FALSE, TRUE, TRUE, TRUE };
int PieceMin[13] = { FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, \
TRUE, TRUE, FALSE, FALSE, FALSE };
int PieceVal[13] = { 0, 100, 325, 325, 550, 1000, 50000, 100, 325, 325, 550, \
1000, 50000 };
int PieceCol[13] = { BOTH, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE,
    BLACK, BLACK, BLACK, BLACK, BLACK, BLACK };\
\>", "Text",
 CellChangeTimes->{
  3.8597574342820807`*^9},ExpressionUUID->"edfb31a7-1877-4ae5-abd7-\
b9a42f9d7725"],

Cell["\<\
void UpdateListsMaterial(S_BOARD* pos) {

    int piece, sq, index, colour;

    for (index = 0; index < BRD_SQ_NUM; ++index) {
        sq = index;
        piece = pos->pieces[index];
        if (piece != e) {
            colour = PieceCol[piece];

            if (PieceBig[piece] == TRUE) pos->bigPce[colour]++;
            if (PieceMin[piece] == TRUE) pos->minPce[colour]++;
            if (PieceMaj[piece] == TRUE) pos->majPce[colour]++;

            pos->material[colour] += PieceVal[piece];

            pos->pList[piece][pos->pceNum[piece]] = sq;
            pos->pceNum[piece]++;

            if (piece == K) pos->KingSq[WHITE] = sq;
            if (piece == k) pos->KingSq[BLACK] = sq;

            if (piece == P) {
                SETBIT(pos->pawns[WHITE], sq);
                SETBIT(pos->pawns[BOTH], sq);
            }
            else if (piece == p) {
                SETBIT(pos->pawns[BLACK], sq);
                SETBIT(pos->pawns[BOTH], sq);
            }
        }
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859757491620816*^9},ExpressionUUID->"cd56be02-11bf-49d2-be0d-\
93320df76d22"]
}, Closed]],

Cell[CellGroupData[{

Cell["Rank and File Arrays", "Section",
 CellChangeTimes->{{3.8602438310838223`*^9, 
  3.8602438401825657`*^9}},ExpressionUUID->"fee74736-564d-432a-925b-\
e63545d91727"],

Cell["\<\
What file/rank is a square ? (add InitFilesRanksBrd() to AllInit()):\
\>", "Text",
 CellChangeTimes->{{3.8597577792182693`*^9, 3.8597578198848352`*^9}, {
  3.860243524982177*^9, 
  3.86024352754716*^9}},ExpressionUUID->"ab06c854-0591-48b9-bd75-\
61ba70d47e6b"],

Cell["\<\
int FilesBrd[BRD_SQ_NUM];
int RanksBrd[BRD_SQ_NUM];\
\>", "Text",
 CellChangeTimes->{
  3.859757724123438*^9},ExpressionUUID->"af99a7f9-1cdc-4bb9-a999-\
83452cecc552"],

Cell["\<\
void InitFilesRanksBrd() {

    int index = 0;
    int file = FILE_A;
    int rank = RANK_1;
    int sq = a1;

    for (rank = RANK_1; rank <= RANK_8; ++rank) {
        for (file = FILE_A; file <= FILE_H; ++file) {
            sq = FR2SQ(file, rank);
            FilesBrd[sq] = file;
            RanksBrd[sq] = rank;
        }
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859757745933742*^9},ExpressionUUID->"5cf6e154-aafc-4c98-9f65-\
3d9892235811"]
}, Closed]],

Cell[CellGroupData[{

Cell["SqAttacked", "Section",
 CellChangeTimes->{{3.8597583268049107`*^9, 
  3.8597583336164007`*^9}},ExpressionUUID->"e9009682-d816-4caf-a608-\
2fcd0062f3c4"],

Cell["\<\
const int KnDir[8] = { -6, -17, -15, -10, 6, 17, 15, 10 };
const int RkDir[4] = { -1, -8, 1, 8 };
const int BiDir[4] = { -7, -9, 7, 9 };
const int KiDir[8] = { -1, -8, 1, 8, -7, -9, 7, 9 };\
\>", "Text",
 CellChangeTimes->{{3.8597585510024443`*^9, 
  3.859758573568409*^9}},ExpressionUUID->"e92b5067-d1cd-4150-bc04-\
4998c77b75c4"],

Cell["\<\
int PiecePawn[13] = { FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, \
FALSE, FALSE, FALSE, FALSE, FALSE };
int PieceKnight[13] = { FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, \
FALSE, TRUE, FALSE, FALSE, FALSE, FALSE };
int PieceKing[13] = { FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, \
FALSE, FALSE, FALSE, FALSE, TRUE };
int PieceRookQueen[13] = { FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, \
FALSE, FALSE, FALSE, TRUE, TRUE, FALSE };
int PieceBishopQueen[13] = { FALSE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, \
FALSE, FALSE, TRUE, FALSE, TRUE, FALSE };
int PieceSlides[13] = { FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, \
FALSE, TRUE, TRUE, TRUE, FALSE };\
\>", "Text",
 CellChangeTimes->{
  3.8597587106012373`*^9},ExpressionUUID->"d26ce50b-8f9d-405a-af3d-\
27bacd97ef4a"],

Cell["\<\
Is square attacked by side? - needed in particular to check if king is in \
check or squares in between king and rook to castle with are attacked by any \
piece of opposite color.\
\>", "Text",
 CellChangeTimes->{{3.8597585510024443`*^9, 3.859758586736752*^9}, 
   3.859758714163207*^9},ExpressionUUID->"12f9dbed-49a4-4f40-a38b-\
80aab6672dc7"],

Cell["\<\
int SqAttacked(const int sq, const int side, const S_BOARD* pos) {

    int cs, rs, ct, rt, pce, index, t_sq, dir;

    cs = COL(sq);
    rs = ROW(sq);

    // pawns
    if (side == WHITE) {
        t_sq = sq - 9;
        ct = COL(t_sq);
        if (pos->pieces[sq - 9] == P && (0 <= t_sq) && (t_sq <= 63) && (-1 <= \
(cs - ct)) && ((cs - ct) <= 1)) {
            return TRUE;
        }
        t_sq = sq - 7;
        ct = COL(t_sq);
        if (pos->pieces[t_sq] == P && (0 <= t_sq) && (t_sq <= 63) && (-1 <= \
(cs - ct)) && ((cs - ct) <= 1)) {
            return TRUE;
        }
    }
    else {
        t_sq = sq + 9;
        ct = COL(t_sq);
        if (pos->pieces[t_sq] == p && (0 <= t_sq) && (t_sq <= 63) && (-1 <= \
(cs - ct)) && ((cs - ct) <= 1)) {
            return TRUE;
        }
        t_sq = sq + 7;
        ct = COL(t_sq);
        if (pos->pieces[t_sq] == p && (0 <= t_sq) && (t_sq <= 63) && (-1 <= \
(cs - ct)) && ((cs - ct) <= 1)) {
            return TRUE;
        }
    }

    // knights
    for (index = 0; index < 8; ++index) {
        t_sq = sq + KnDir[index];
        pce = pos->pieces[t_sq];
        ct = COL(t_sq);
        rt = ROW(t_sq);
        if (((0 <= t_sq) && (t_sq <= 63) && (-2 <= (cs - ct)) && ((cs - ct) \
<= 2) && (-2 <= (rs - rt)) && ((rs - rt) <= 2)) && IsKn(pce) && PieceCol[pce] \
== side) {
            return TRUE;
        }
    }

    // rooks, queens
    for (index = 0; index < 4; ++index) {
        dir = RkDir[index];
        t_sq = sq + dir;
        cs = COL(sq);
        rs = ROW(sq);
        ct = COL(t_sq);
        rt = ROW(t_sq);

        if ((0 <= t_sq) && (t_sq <= 63))
        {
            pce = pos->pieces[t_sq];
        }
        else
        {
            pce = e;
        }
        while ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1)) {
            if (pce != e) {
                if (IsRQ(pce) && PieceCol[pce] == side) {
                    return TRUE;
                }
                break;
            }
            cs = COL(t_sq);
            rs = ROW(t_sq);
            t_sq += dir;
            if ((0 <= t_sq) && (t_sq <= 63))
            {
                pce = pos->pieces[t_sq];
            }
            else
            {
                pce = e;
            }
            ct = COL(t_sq);
            rt = ROW(t_sq);
        }
    }

    // bishops, queens
    for (index = 0; index < 4; ++index) {
        dir = BiDir[index];
        t_sq = sq + dir;
        cs = COL(sq);
        rs = ROW(sq);
        ct = COL(t_sq);
        rt = ROW(t_sq);

        if ((0 <= t_sq) && (t_sq <= 63))
        {
            pce = pos->pieces[t_sq];
        }
        else
        {
            pce = e;
        }
        while ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1)) {
            if (pce != e) {
                if (IsBQ(pce) && PieceCol[pce] == side) {
                    return TRUE;
                }
                break;
            }
            cs = COL(t_sq);
            rs = ROW(t_sq);
            t_sq += dir; //if (sq == 4 && dir == 7) { printf(\"t_sq %d\\n\", \
t_sq); }
            if ((0 <= t_sq) && (t_sq <= 63))
            {
                pce = pos->pieces[t_sq];
            }
            else
            {
                pce = e;
            }
            ct = COL(t_sq);
            rt = ROW(t_sq);
        }
    }

    cs = COL(sq);
    rs = ROW(sq);

    // kings
    for (index = 0; index < 8; ++index) {
        t_sq = sq + KiDir[index];
        pce = pos->pieces[t_sq];
        ct = COL(t_sq);
        rt = ROW(t_sq);
        if (((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1)) && IsKi(pce) && PieceCol[pce] \
== side) {
            return TRUE;
        }
    }

    return FALSE;

}\
\>", "Text",
 CellChangeTimes->{
  3.8597585510024443`*^9},ExpressionUUID->"8ae1ea75-331e-4e77-856f-\
cdfd446b107a"]
}, Closed]],

Cell[CellGroupData[{

Cell["Move Structure", "Section",
 CellChangeTimes->{{3.859758340222906*^9, 
  3.859758345447365*^9}},ExpressionUUID->"62acae9b-452d-4f1d-bd98-\
21b43fe66dd1"],

Cell["\<\
typedef struct {
    int move;
    int score;
} S_MOVE;\
\>", "Text",
 CellChangeTimes->{
  3.8597590113080482`*^9},ExpressionUUID->"9c64c289-6049-45ea-b345-\
e3677a40535d"],

Cell["\<\
0000 0000 0000 0000 0000 0111 1111 -> From 0x7F
0000 0000 0000 0011 1111 1000 0000 -> To >> 7, 0x7F
0000 0000 0011 1100 0000 0000 0000 -> Captured >> 14, 0xF
0000 0000 0100 0000 0000 0000 0000 -> EP 0x40000
0000 0000 1000 0000 0000 0000 0000 -> Pawn Start 0x80000
0000 1111 0000 0000 0000 0000 0000 -> Promoted Piece >> 20, 0xF
0001 0000 0000 0000 0000 0000 0000 -> Castle 0x1000000\
\>", "Text",
 CellChangeTimes->{
  3.85975910673392*^9},ExpressionUUID->"a9189b2c-0e9d-456c-992d-8c8e45acdbf8"],

Cell["\<\
To find the masked value which will give the index of the move, captured type \
index and promoted type index \
\>", "Text",
 CellChangeTimes->{{3.859759324433918*^9, 3.859759344120956*^9}, 
   3.86024113353094*^9},ExpressionUUID->"4856270c-9e28-46b2-af16-\
9783439992fd"],

Cell["\<\
#define FROMSQ(m) ((m) & 0x7F)
#define TOSQ(m) (((m)>>7) & 0x7F)
#define CAPTURED(m) (((m)>>14) & 0xF)
#define PROMOTED(m) (((m)>>20) & 0xF)

The values which will &'d with moves to see if the corrsponding bits are set \
or not uses hexadecimal numbers\
\>", "Text",
 CellChangeTimes->{{3.859759324433918*^9, 3.859759344120956*^9}, {
  3.860241137613915*^9, 
  3.86024114291476*^9}},ExpressionUUID->"0b80b2fd-5d82-4989-a897-\
5de88e7a99bd"],

Cell["\<\
#define MFLAGEP 0x40000
#define MFLAGPS 0x80000
#define MFLAGCA 0x1000000\
\>", "Text",
 CellChangeTimes->{{3.859759324433918*^9, 3.859759344120956*^9}, {
  3.860241137613915*^9, 
  3.860241141832933*^9}},ExpressionUUID->"2c0e7b11-70f4-460d-b572-\
0760666fc4a8"],

Cell["Flag to see if the capturing is happening or not", "Text",
 CellChangeTimes->{
  3.85975938977955*^9, {3.860241123194174*^9, 
   3.860241145575727*^9}},ExpressionUUID->"afa46df9-e956-452d-bd04-\
284335ae3fe0"],

Cell["\<\
#define MFLAGCAP 0x7C000
#define MFLAGPROM 0xF00000\
\>", "Text",
 CellChangeTimes->{
  3.85975938977955*^9, {3.860241123194174*^9, 
   3.860241124440052*^9}},ExpressionUUID->"e7399bed-e76b-4091-80ce-\
fc46b561bfd3"]
}, Closed]],

Cell[CellGroupData[{

Cell["PrintMove and PrintSquare", "Section",
 CellChangeTimes->{{3.860252828516818*^9, 
  3.860252839062591*^9}},ExpressionUUID->"a7fd6c14-d30d-4314-b4cf-\
165eb8174a52"],

Cell["\<\
Print the file and rank of a current square using the file and rank arrays\
\>", "Text",
 CellChangeTimes->{
  3.8597597321760283`*^9, {3.860241316282648*^9, 
   3.860241319165277*^9}},ExpressionUUID->"beaffe02-f4af-461f-b344-\
0de074bc0e7f"],

Cell["\<\
char* PrSq(const int sq) {

    static char SqStr[3];

    int file = FilesBrd[sq];
    int rank = RanksBrd[sq];

    sprintf(SqStr, \"%c%c\", ('a' + file), ('1' + rank));

    return SqStr;

}\
\>", "Text",
 CellChangeTimes->{3.8597597321760283`*^9, 
  3.860277169091507*^9},ExpressionUUID->"a4d77d28-cb05-449d-8085-\
d9a671b0952a"],

Cell["Print the from, to and promoted bit values of the move", "Text",
 CellChangeTimes->{
  3.859759765764297*^9, {3.860241330280877*^9, 
   3.860241333058342*^9}},ExpressionUUID->"458f9c3e-5661-4fd0-abc4-\
adcd57b04fac"],

Cell["\<\
char* PrMove(const int move) {

    static char MvStr[6];

    int ff = FilesBrd[FROMSQ(move)];
    int rf = RanksBrd[FROMSQ(move)];
    int ft = FilesBrd[TOSQ(move)];
    int rt = RanksBrd[TOSQ(move)];

    int promoted = PROMOTED(move);

    if (promoted) {
        char pchar = 'q';
        if (IsKn(promoted)) {
            pchar = 'n';
        }
        else if (IsRQ(promoted) && !IsBQ(promoted)) {
            pchar = 'r';
        }
        else if (!IsRQ(promoted) && IsBQ(promoted)) {
            pchar = 'b';
        }
        sprintf(MvStr, \"%c%c%c%c%c\", ('a' + ff), ('1' + rf), ('a' + ft), \
('1' + rt), pchar);
    }
    else {
        sprintf(MvStr, \"%c%c%c%c\", ('a' + ff), ('1' + rf), ('a' + ft), ('1' \
+ rt));
    }

    return MvStr;
}\
\>", "Text",
 CellChangeTimes->{
  3.859759765764297*^9, {3.860241330280877*^9, 
   3.860241330394754*^9}},ExpressionUUID->"865e1413-996d-411b-afcf-\
abbaee269e32"]
}, Closed]],

Cell[CellGroupData[{

Cell["Move Generation", "Section",
 CellChangeTimes->{{3.8597602346073437`*^9, 
  3.85976024073936*^9}},ExpressionUUID->"0131a07b-0bdb-4b5f-ad2f-\
eb5c30ca4e12"],

Cell["\<\
#define MOVE(f,t,ca,pro,fl) ( (f) | ((t) << 7) | ( (ca) << 14 ) | ( (pro) << \
20 ) | (fl))

//These arrays enable generation of moves for sliding pieces of both sides as \
they define the starting 
//index of white and black sliding pieces and when we reach a 0 we have \
completed one side\[CloseCurlyQuote]s sliding pieces 
const int LoopSlidePce[8] = {
 B, R, Q, 0, b, r, q, 0
};

const int LoopNonSlidePce[6] = {
 N, K, 0, n, k, 0
};

const int LoopSlideIndex[2] = { 0, 4 };
const int LoopNonSlideIndex[2] = { 0, 3 };

//These store the directions for each piece which need to be added to the \
current square...to get all the squares 
//where a type of piece indexed by rows can move; 

const int PceDir[13][8] = {
    { 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0 },
    { -6, -17, -15, -10, 6, 17, 15, 10 },
    { -7, -9, 7, 9, 0, 0, 0, 0 },
    { -1, -8, 1, 8, 0, 0, 0, 0 },
    { -1, -8, 1, 8, -7, -9, 7, 9 },
    { -1, -8, 1, 8, -7, -9, 7, 9 },
    { 0, 0, 0, 0, 0, 0, 0 },
    { -6, -17, -15, -10, 6, 17, 15, 10 },
    { -7, -9, 7, 9, 0, 0, 0, 0 },
    { -1, -8, 1, 8, 0, 0, 0, 0 },
    { -1, -8, 1, 8, -7, -9, 7, 9 },
    { -1, -8, 1, 8, -7, -9, 7, 9 }
};

//The number of directions for each piece type - for queen 8, bishop and rook \
4 
const int NumDir[13] = {
 0, 0, 8, 4, 4, 8, 8, 0, 8, 4, 4, 8, 8
};

void GenerateAllMoves(const S_BOARD* pos, S_MOVELIST* list);

static void AddQuietMove(const S_BOARD* pos, int move, S_MOVELIST* list) {

    list->moves[list->count].move = move;

    if (pos->searchKillers[0][pos->ply] == move) {
        list->moves[list->count].score = 900000;
    }
    else if (pos->searchKillers[1][pos->ply] == move) {
        list->moves[list->count].score = 800000;
    }
    else {
        list->moves[list->count].score = \
pos->searchHistory[pos->pieces[FROMSQ(move)]][TOSQ(move)];
    }
    list->count++;
}

static void AddCaptureMove(const S_BOARD* pos, int move, S_MOVELIST* list) {

    list->moves[list->count].move = move;
    list->moves[list->count].score = \
MvvLvaScores[CAPTURED(move)][pos->pieces[FROMSQ(move)]] + 1000000;
    list->count++;
}

static void AddEnPassantMove(const S_BOARD* pos, int move, S_MOVELIST* list) {

    list->moves[list->count].move = move;
    list->moves[list->count].score = 105 + 1000000;
    list->count++;
}

static void AddWhitePawnCapMove(const S_BOARD* pos, const int from, const int \
to, const int cap, S_MOVELIST* list) {

    if (RanksBrd[from] == RANK_7) {
        AddCaptureMove(pos, MOVE(from, to, cap, Q, 0), list);
        AddCaptureMove(pos, MOVE(from, to, cap, R, 0), list);
        AddCaptureMove(pos, MOVE(from, to, cap, B, 0), list);
        AddCaptureMove(pos, MOVE(from, to, cap, N, 0), list);
    }
    else {
        AddCaptureMove(pos, MOVE(from, to, cap, e, 0), list);
    }
}

static void AddWhitePawnMove(const S_BOARD* pos, const int from, const int \
to, S_MOVELIST* list) {

    if (RanksBrd[from] == RANK_7) {
        AddQuietMove(pos, MOVE(from, to, e, Q, 0), list);
        AddQuietMove(pos, MOVE(from, to, e, R, 0), list);
        AddQuietMove(pos, MOVE(from, to, e, B, 0), list);
        AddQuietMove(pos, MOVE(from, to, e, N, 0), list);
    }
    else {
        AddQuietMove(pos, MOVE(from, to, e, e, 0), list);
    }
}

static void AddBlackPawnCapMove(const S_BOARD* pos, const int from, const int \
to, const int cap, S_MOVELIST* list) {

    if (RanksBrd[from] == RANK_2) {
        AddCaptureMove(pos, MOVE(from, to, cap, q, 0), list);
        AddCaptureMove(pos, MOVE(from, to, cap, r, 0), list);
        AddCaptureMove(pos, MOVE(from, to, cap, b, 0), list);
        AddCaptureMove(pos, MOVE(from, to, cap, n, 0), list);
    }
    else {
        AddCaptureMove(pos, MOVE(from, to, cap, e, 0), list);
    }
}

static void AddBlackPawnMove(const S_BOARD* pos, const int from, const int \
to, S_MOVELIST* list) {

    if (RanksBrd[from] == RANK_2) {
        AddQuietMove(pos, MOVE(from, to, e, q, 0), list);
        AddQuietMove(pos, MOVE(from, to, e, r, 0), list);
        AddQuietMove(pos, MOVE(from, to, e, b, 0), list);
        AddQuietMove(pos, MOVE(from, to, e, n, 0), list);
    }
    else {
        AddQuietMove(pos, MOVE(from, to, e, e, 0), list);
    }
}

void GenerateAllMoves(const S_BOARD* pos, S_MOVELIST* list) {

    list->count = 0;

    int pce = e;
    int side = pos->side;
    int sq = 0; int t_sq = 0;
    int pceNum = 0;
    int dir = 0;
    int index = 0;
    int pceIndex = 0;

    int cs, ct, rs, rt;

    if (side == WHITE) {

        for (pceNum = 0; pceNum < pos->pceNum[P]; ++pceNum) {
            sq = pos->pList[P][pceNum];

            if ((sq + 8 <= 63) && pos->pieces[sq + 8] == e) {
                AddWhitePawnMove(pos, sq, sq + 8, list);
                if (RanksBrd[sq] == RANK_2 && pos->pieces[sq + 16] == e) {
                    AddQuietMove(pos, MOVE(sq, (sq + 16), e, e, MFLAGPS), \
list);
                }
            }

            t_sq = sq + 7;
            cs = COL(sq);
            ct = COL(t_sq);
            rs = ROW(sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && \
(PieceCol[pos->pieces[sq + 7]] == BLACK)) {
                AddWhitePawnCapMove(pos, sq, sq + 7, pos->pieces[sq + 7], \
list);
            }
            t_sq = sq + 9;
            ct = COL(t_sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && \
(PieceCol[pos->pieces[sq + 9]] == BLACK)) {
                AddWhitePawnCapMove(pos, sq, sq + 9, pos->pieces[sq + 9], \
list);
            }

            if (pos->enPas != no_sq) {
                ct = COL(sq + 7);
                if ((sq + 7 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq + 7, e, e, MFLAGEP), \
list);
                }
                ct = COL(sq + 9);
                if ((sq + 9 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq + 9, e, e, MFLAGEP), \
list);
                }
            }
        }

        if (pos->castlePerm & WKCA) {
            if (pos->pieces[f1] == e && pos->pieces[g1] == e) {
                if (!SqAttacked(e1, BLACK, pos) && !SqAttacked(f1, BLACK, \
pos)) {
                    AddQuietMove(pos, MOVE(e1, g1, e, e, MFLAGCA), list);
                }
            }
        }

        if (pos->castlePerm & WQCA) {
            if (pos->pieces[d1] == e && pos->pieces[c1] == e && \
pos->pieces[b1] == e) {
                if (!SqAttacked(e1, BLACK, pos) && !SqAttacked(d1, BLACK, \
pos)) {
                    AddQuietMove(pos, MOVE(e1, c1, e, e, MFLAGCA), list);
                }
            }
        }

    }
    else {

        for (pceNum = 0; pceNum < pos->pceNum[p]; ++pceNum) {
            sq = pos->pList[p][pceNum];

            if ((0 <= sq - 8) && pos->pieces[sq - 8] == e) {
                AddBlackPawnMove(pos, sq, sq - 8, list);
                if (RanksBrd[sq] == RANK_7 && pos->pieces[sq - 16] == e) {
                    AddQuietMove(pos, MOVE(sq, (sq - 16), e, e, MFLAGPS), \
list);
                }
            }

            t_sq = sq - 7;
            cs = COL(sq);
            ct = COL(t_sq);
            rs = ROW(sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && \
(PieceCol[pos->pieces[sq - 7]] == WHITE)) {
                AddBlackPawnCapMove(pos, sq, sq - 7, pos->pieces[sq - 7], \
list);
            }
            t_sq = sq - 9;
            ct = COL(t_sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && \
(PieceCol[pos->pieces[sq - 9]] == WHITE)) {
                AddBlackPawnCapMove(pos, sq, sq - 9, pos->pieces[sq - 9], \
list);
            }
            if (pos->enPas != no_sq) {
                ct = COL(sq - 7);
                if ((sq - 7 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq - 7, e, e, MFLAGEP), \
list);
                }
                ct = COL(sq - 9);
                if ((sq - 9 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq - 9, e, e, MFLAGEP), \
list);
                }
            }
        }

        // castling
        if (pos->castlePerm & BKCA) {
            if (pos->pieces[f8] == e && pos->pieces[g8] == e) {
                if (!SqAttacked(e8, WHITE, pos) && !SqAttacked(f8, WHITE, \
pos)) {
                    AddQuietMove(pos, MOVE(e8, g8, e, e, MFLAGCA), list);
                }
            }
        }

        if (pos->castlePerm & BQCA) {
            if (pos->pieces[d8] == e && pos->pieces[c8] == e && \
pos->pieces[b8] == e) {
                if (!SqAttacked(e8, WHITE, pos) && !SqAttacked(d8, WHITE, \
pos)) {
                    AddQuietMove(pos, MOVE(e8, c8, e, e, MFLAGCA), list);
                }
            }
        }
    }

    //The break statement ends the loop immediately when it is encountered. 
    //The continue statement skips the current iteration of the loop and \
continues with the next iteration. 

    /* Loop for slider pieces */
    pceIndex = LoopSlideIndex[side];
    pce = LoopSlidePce[pceIndex++];
    while (pce != 0) {\t\t

        for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
            sq = pos->pList[pce][pceNum];

            for (index = 0; index < NumDir[pce]; ++index) {
                dir = PceDir[pce][index];
                t_sq = sq + dir;

                cs = COL(sq);
                ct = COL(t_sq);
                rs = ROW(sq);
                rt = ROW(t_sq);

                while ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && \
((cs - ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1)) {
                    // BLACK ^ 1 == WHITE       WHITE ^ 1 == BLACK
                    if (pos->pieces[t_sq] != e) {
                        if (PieceCol[pos->pieces[t_sq]] == (side ^ 1)) {
                            AddCaptureMove(pos, MOVE(sq, t_sq, \
pos->pieces[t_sq], e, 0), list);
                        }
                        break;
                    }
                    AddQuietMove(pos, MOVE(sq, t_sq, e, e, 0), list);
                    cs = COL(t_sq);
                    rs = ROW(t_sq);
                    t_sq += dir;
                    ct = COL(t_sq);
                    rt = ROW(t_sq);
                }
            }
        }

        pce = LoopSlidePce[pceIndex++];
    }

    /* Loop for non slider */
    pceIndex = LoopNonSlideIndex[side];
    pce = LoopNonSlidePce[pceIndex++];

    while (pce != 0) {

        for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
            sq = pos->pList[pce][pceNum];

            for (index = 0; index < NumDir[pce]; ++index) {
                dir = PceDir[pce][index];
                t_sq = sq + dir;

                cs = COL(sq);
                ct = COL(t_sq);
                rs = ROW(sq);
                rt = ROW(t_sq);

                if ((pce == N || pce == n) && !((0 <= t_sq) && (t_sq <= 63) \
&& (-2 <= (cs - ct)) && ((cs - ct) <= 2) && (-2 <= (rs - rt)) && ((rs - rt) \
<= 2)))
                {
                    continue;
                }

                if ((pce == K || pce == k) && !((0 <= t_sq) && (t_sq <= 63) \
&& (-1 <= (cs - ct)) && ((cs - ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) \
<= 1)))
                {
                    continue;
                }

                // BLACK ^ 1 == WHITE       WHITE ^ 1 == BLACK
                if (pos->pieces[t_sq] != e) {
                    if (PieceCol[pos->pieces[t_sq]] == (side ^ 1)) {
                        AddCaptureMove(pos, MOVE(sq, t_sq, pos->pieces[t_sq], \
e, 0), list);
                    }
                    continue;
                }
                AddQuietMove(pos, MOVE(sq, t_sq, e, e, 0), list);
            }
        }

        pce = LoopNonSlidePce[pceIndex++];
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859760245867516*^9, {3.85992927496665*^9, 3.859929281923123*^9}, 
   3.860241201476799*^9, {3.860241271570979*^9, 
   3.86024128886203*^9}},ExpressionUUID->"7044cb7b-609c-4537-b0a5-\
0ee12069edcc"],

Cell["\<\
GenerateAllCaps is mostly the same function as GenerateAllMoves, but it only \
generates the capture moves which are required in the Quiescence search \
function\
\>", "Text",
 CellChangeTimes->{
  3.859760245867516*^9, {3.85992927496665*^9, 3.859929281923123*^9}, 
   3.860241201476799*^9, {3.860241271570979*^9, 
   3.860241294903125*^9}},ExpressionUUID->"00f3ea2b-557f-4cd3-a5f9-\
2913b3dbc873"],

Cell["\<\
void GenerateAllCaps(const S_BOARD* pos, S_MOVELIST* list) {

    list->count = 0;

    int pce = e;
    int side = pos->side;
    int sq = 0; int t_sq = 0;
    int pceNum = 0;
    int dir = 0;
    int index = 0;
    int pceIndex = 0;

    int cs, ct, rs, rt;

    if (side == WHITE) {

        for (pceNum = 0; pceNum < pos->pceNum[P]; ++pceNum) {
            sq = pos->pList[P][pceNum];

            t_sq = sq + 7;
            cs = COL(sq);
            ct = COL(t_sq);
            rs = ROW(sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && \
(PieceCol[pos->pieces[sq + 7]] == BLACK)) {
                AddWhitePawnCapMove(pos, sq, sq + 7, pos->pieces[sq + 7], \
list);
            }
            t_sq = sq + 9;
            ct = COL(t_sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && PieceCol[pos->pieces[sq \
+ 9]] == BLACK) {
                AddWhitePawnCapMove(pos, sq, sq + 9, pos->pieces[sq + 9], \
list);
            }

            if (pos->enPas != no_sq) {
                ct = COL(sq + 7);
                if ((sq + 7 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq + 7, e, e, MFLAGEP), \
list);
                }
                ct = COL(sq + 9);
                if ((sq + 9 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq + 9, e, e, MFLAGEP), \
list);
                }
            }
        }

    }
    else {

        for (pceNum = 0; pceNum < pos->pceNum[p]; ++pceNum) {
            sq = pos->pList[p][pceNum];

            t_sq = sq - 7;
            cs = COL(sq);
            ct = COL(t_sq);
            rs = ROW(sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && \
(PieceCol[pos->pieces[sq - 7]] == WHITE)) {
                AddBlackPawnCapMove(pos, sq, sq - 7, pos->pieces[sq - 7], \
list);
            }
            t_sq = sq - 9;
            ct = COL(t_sq);
            rt = ROW(t_sq);
            if ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && ((cs - \
ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1) && \
(PieceCol[pos->pieces[sq - 9]] == WHITE)) {
                AddBlackPawnCapMove(pos, sq, sq - 9, pos->pieces[sq - 9], \
list);
            }
            if (pos->enPas != no_sq) {
                ct = COL(sq - 7);
                if ((sq - 7 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq - 7, e, e, MFLAGEP), \
list);
                }
                ct = COL(sq - 9);
                if ((sq - 9 == pos->enPas) && (-1 <= (cs - ct)) && ((cs - ct) \
<= 1)) {
                    AddEnPassantMove(pos, MOVE(sq, sq - 9, e, e, MFLAGEP), \
list);
                }
            }
        }
    }

    /* Loop for slider pieces */
    pceIndex = LoopSlideIndex[side];
    pce = LoopSlidePce[pceIndex++];
    while (pce != 0) {

        for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
            sq = pos->pList[pce][pceNum];

            for (index = 0; index < NumDir[pce]; ++index) {
                dir = PceDir[pce][index];
                t_sq = sq + dir;

                cs = COL(sq);
                ct = COL(t_sq);
                rs = ROW(sq);
                rt = ROW(t_sq);

                while ((0 <= t_sq) && (t_sq <= 63) && (-1 <= (cs - ct)) && \
((cs - ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) <= 1)) {
                    // BLACK ^ 1 == WHITE       WHITE ^ 1 == BLACK
                    if (pos->pieces[t_sq] != e) {
                        if (PieceCol[pos->pieces[t_sq]] == (side ^ 1)) {
                            AddCaptureMove(pos, MOVE(sq, t_sq, \
pos->pieces[t_sq], e, 0), list);
                        }
                        break;
                    }
                    cs = COL(t_sq);
                    rs = ROW(t_sq);
                    t_sq += dir;
                    ct = COL(t_sq);
                    rt = ROW(t_sq);
                }
            }
        }

        pce = LoopSlidePce[pceIndex++];
    }

    /* Loop for non slider */
    pceIndex = LoopNonSlideIndex[side];
    pce = LoopNonSlidePce[pceIndex++];

    while (pce != 0) {

        for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
            sq = pos->pList[pce][pceNum];

            for (index = 0; index < NumDir[pce]; ++index) {
                dir = PceDir[pce][index];
                t_sq = sq + dir;

                cs = COL(sq);
                ct = COL(t_sq);
                rs = ROW(sq);
                rt = ROW(t_sq);

                if ((pce == N || pce == n) && !((0 <= t_sq) && (t_sq <= 63) \
&& (-2 <= (cs - ct)) && ((cs - ct) <= 2) && (-2 <= (rs - rt)) && ((rs - rt) \
<= 2)))
                {
                    continue;
                }

                if ((pce == K || pce == k) && !((0 <= t_sq) && (t_sq <= 63) \
&& (-1 <= (cs - ct)) && ((cs - ct) <= 1) && (-1 <= (rs - rt)) && ((rs - rt) \
<= 1)))
                {
                    continue;
                }

                // BLACK ^ 1 == WHITE       WHITE ^ 1 == BLACK
                if (pos->pieces[t_sq] != e) {
                    if (PieceCol[pos->pieces[t_sq]] == (side ^ 1)) {
                        AddCaptureMove(pos, MOVE(sq, t_sq, pos->pieces[t_sq], \
e, 0), list);
                    }
                    continue;
                }
            }
        }

        pce = LoopNonSlidePce[pceIndex++];
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859760245867516*^9, {3.85992927496665*^9, 3.859929281923123*^9}, 
   3.860241201476799*^9, {3.860241271570979*^9, 
   3.860241298200794*^9}},ExpressionUUID->"9f18c4f7-639a-4ddc-bed3-\
83582ce9eabc"]
}, Closed]],

Cell[CellGroupData[{

Cell["MakeMove TakeMove", "Section",
 CellChangeTimes->{{3.859758352999134*^9, 
  3.859758364575511*^9}},ExpressionUUID->"2e32f6da-b4ac-4620-baf4-\
e7adad53e115"],

Cell["\<\
#define HASH_PCE(pce,sq) (pos->posKey ^= (PieceKeys[(pce)][(sq)]))
#define HASH_CA (pos->posKey ^= (CastleKeys[(pos->castlePerm)]))
#define HASH_SIDE (pos->posKey ^= (SideKey))
#define HASH_EP (pos->posKey ^= (PieceKeys[e][(pos->enPas)]))\
\>", "Text",
 CellChangeTimes->{3.859760379179088*^9, 
  3.860241347083868*^9},ExpressionUUID->"ce2f5248-5578-4531-b139-\
15fd60b9116f"],

Cell["\<\
const int CastlePerm[120] = {
    13, 15, 15, 15, 12, 15, 15, 14,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    7, 15, 15, 15,  3, 15, 15, 11
};\
\>", "Text",
 CellChangeTimes->{
  3.859760379179088*^9, {3.8602413511192513`*^9, 
   3.860241354958735*^9}},ExpressionUUID->"7b498356-07f1-4e69-bf8b-\
0b19a0a3cfee"],

Cell["\<\
static void ClearPiece(const int sq, S_BOARD* pos) {

    int pce = pos->pieces[sq];

    int col = PieceCol[pce];
    int index = 0;
    int t_pceNum = -1;

    HASH_PCE(pce, sq);

    pos->pieces[sq] = e;
    pos->material[col] -= PieceVal[pce];

    if (PieceBig[pce]) {
        pos->bigPce[col]--;
        if (PieceMaj[pce]) {
            pos->majPce[col]--;
        }
        else {
            pos->minPce[col]--;
        }
    }
    else {
        CLRBIT(pos->pawns[col], sq);
        CLRBIT(pos->pawns[BOTH], sq);
    }

    for (index = 0; index < pos->pceNum[pce]; ++index) {
        if (pos->pList[pce][index] == sq) {
            t_pceNum = index;
            break;
        }
    }

    pos->pceNum[pce]--;

    pos->pList[pce][t_pceNum] = pos->pList[pce][pos->pceNum[pce]];

}\
\>", "Text",
 CellChangeTimes->{
  3.859760379179088*^9, {3.860241358631279*^9, 
   3.860241371501926*^9}},ExpressionUUID->"c7a580c1-15b9-4884-91bd-\
b39978d2a884"],

Cell["\<\
static void AddPiece(const int sq, S_BOARD* pos, const int pce) {

    int col = PieceCol[pce];

    HASH_PCE(pce, sq);

    pos->pieces[sq] = pce;

    if (PieceBig[pce]) {
        pos->bigPce[col]++;
        if (PieceMaj[pce]) {
            pos->majPce[col]++;
        }
        else {
            pos->minPce[col]++;
        }
    }
    else {
        SETBIT(pos->pawns[col], sq);
        SETBIT(pos->pawns[BOTH], sq);
    }

    pos->material[col] += PieceVal[pce];
    pos->pList[pce][pos->pceNum[pce]++] = sq;

}\
\>", "Text",
 CellChangeTimes->{
  3.859760379179088*^9, {3.860241358631279*^9, 
   3.860241381117741*^9}},ExpressionUUID->"29ad9cbc-41a4-4133-bc02-\
d48c77cc5be2"],

Cell["\<\
static void MovePiece(const int from, const int to, S_BOARD* pos) {

    int index = 0;
    int pce = pos->pieces[from];
    int col = PieceCol[pce];

    HASH_PCE(pce, from);
    pos->pieces[from] = e;

    HASH_PCE(pce, to);
    pos->pieces[to] = pce;

    if (!PieceBig[pce]) {
        CLRBIT(pos->pawns[col], from);
        CLRBIT(pos->pawns[BOTH], from);
        SETBIT(pos->pawns[col], to);
        SETBIT(pos->pawns[BOTH], to);
    }

    for (index = 0; index < pos->pceNum[pce]; ++index) {
        if (pos->pList[pce][index] == from) {
            pos->pList[pce][index] = to;
            break;
        }
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859760379179088*^9, {3.860241358631279*^9, 
   3.860241388994514*^9}},ExpressionUUID->"fec1540b-71ef-4a9a-8bdd-\
2c817aabf0bf"],

Cell["\<\
int MakeMove(S_BOARD* pos, int move) {

    int from = FROMSQ(move);
    int to = TOSQ(move);
    int side = pos->side;

    pos->history[pos->hisPly].posKey = pos->posKey;

    if (move & MFLAGEP) {
        if (side == WHITE) {
            ClearPiece(to - 8, pos);
        }
        else {
            ClearPiece(to + 8, pos);
        }
    }
    else if (move & MFLAGCA) {
        switch (to) {
        case c1:
            MovePiece(a1, d1, pos);
            break;
        case c8:
            MovePiece(a8, d8, pos);
            break;
        case g1:
            MovePiece(h1, f1, pos);
            break;
        case g8:
            MovePiece(h8, f8, pos);
            break;
        default:
            break;
        }
    }

    if (pos->enPas != no_sq) HASH_EP;
    HASH_CA;

    pos->history[pos->hisPly].move = move;
    pos->history[pos->hisPly].fiftyMove = pos->fiftyMove;
    pos->history[pos->hisPly].enPas = pos->enPas;
    pos->history[pos->hisPly].castlePerm = pos->castlePerm;

    pos->castlePerm &= CastlePerm[from];
    pos->castlePerm &= CastlePerm[to];
    pos->enPas = no_sq;

    HASH_CA;

    int captured = CAPTURED(move);
    pos->fiftyMove++;

    if (captured != e) {
        ClearPiece(to, pos);
        pos->fiftyMove = 0;
    }

    pos->hisPly++;
    pos->ply++;

    if (PiecePawn[pos->pieces[from]]) {
        pos->fiftyMove = 0;
        if (move & MFLAGPS) {
            if (side == WHITE) {
                pos->enPas = from + 8;
            }
            else {
                pos->enPas = from - 8;
            }
            HASH_EP;
        }
    }

    MovePiece(from, to, pos);

    int prPce = PROMOTED(move);
    if (prPce != e) {
        ClearPiece(to, pos);
        AddPiece(to, pos, prPce);
    }

    if (PieceKing[pos->pieces[to]]) {
        pos->KingSq[pos->side] = to;
    }

    pos->side ^= 1;
    HASH_SIDE;

    if (SqAttacked(pos->KingSq[side], pos->side, pos)) {
        TakeMove(pos);
        return FALSE;
    }

    return TRUE;
}\
\>", "Text",
 CellChangeTimes->{
  3.859760379179088*^9, {3.860241358631279*^9, 3.8602413978354387`*^9}, {
   3.8602414385311823`*^9, 
   3.860241449494286*^9}},ExpressionUUID->"32ed5fbe-a0d8-41f6-a3e1-\
e4733a1a838d"],

Cell["\<\
void TakeMove(S_BOARD* pos) {

    pos->hisPly--;
    pos->ply--;

    int move = pos->history[pos->hisPly].move;
    int from = FROMSQ(move);
    int to = TOSQ(move);

    if (pos->enPas != no_sq) HASH_EP;
    HASH_CA;

    pos->castlePerm = pos->history[pos->hisPly].castlePerm;
    pos->fiftyMove = pos->history[pos->hisPly].fiftyMove;
    pos->enPas = pos->history[pos->hisPly].enPas;

    if (pos->enPas != no_sq) HASH_EP;
    HASH_CA;

    pos->side ^= 1;
    HASH_SIDE;

    if (MFLAGEP & move) {
        if (pos->side == WHITE) {
            AddPiece(to - 8, pos, p);
        }
        else {
            AddPiece(to + 8, pos, P);
        }
    }
    else if (MFLAGCA & move) {
        switch (to) {
        case c1: MovePiece(d1, a1, pos); break;
        case c8: MovePiece(d8, a8, pos); break;
        case g1: MovePiece(f1, h1, pos); break;
        case g8: MovePiece(f8, h8, pos); break;
        default: break;
        }
    }

    MovePiece(to, from, pos);

    if (PieceKing[pos->pieces[from]]) {
        pos->KingSq[pos->side] = from;
    }

    int captured = CAPTURED(move);
    if (captured != e) {
        AddPiece(to, pos, captured);
    }

    if (PROMOTED(move) != e) {
        ClearPiece(from, pos);
        AddPiece(from, pos, (PieceCol[PROMOTED(move)] == WHITE ? P : p));
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859760379179088*^9, {3.860241358631279*^9, 3.8602413978354387`*^9}, {
   3.8602414385311823`*^9, 
   3.860241452734602*^9}},ExpressionUUID->"4c6e61c0-a1af-4674-9d73-\
9c4cd4b98a3e"]
}, Closed]],

Cell[CellGroupData[{

Cell["Perft", "Section",
 CellChangeTimes->{{3.859758369330411*^9, 
  3.859758370685461*^9}},ExpressionUUID->"c0a97d02-f196-4b90-84d9-\
889569a46f4f"],

Cell["\<\
Doing every possible move to a given depth from a board position.\
\>", "Text",
 CellChangeTimes->{{3.8604337542482*^9, 
  3.860433795348781*^9}},ExpressionUUID->"bbc95a56-93bf-4e21-b8aa-\
30c3ada3cadf"],

Cell["long leafNodes;", "Text",
 CellChangeTimes->{3.859760427108878*^9, 
  3.860241469670176*^9},ExpressionUUID->"768182dd-1e04-4877-a043-\
5ce17978993d"],

Cell["\<\
void Perft(int depth, S_BOARD* pos) {

    if (depth == 0) {
        leafNodes++;
        return;
    }

    S_MOVELIST list[1];
    GenerateAllMoves(pos, list);

    int MoveNum = 0;
    for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {

        //Ignore the illegal moves
        if (!MakeMove(pos, list->moves[MoveNum].move)) {
            continue;
        }
        Perft(depth - 1, pos);
        TakeMove(pos);
    }

    return;
}\
\>", "Text",
 CellChangeTimes->{
  3.859760427108878*^9, {3.860241472852162*^9, 
   3.86024147851302*^9}},ExpressionUUID->"882d443d-c4c9-4012-a17d-\
304aa4bc50b4"],

Cell["\<\
void PerftTest(int depth, S_BOARD* pos) {

    PrintBoard(pos);
    printf(\"\\nStarting Test To Depth:%d\\n\", depth);
    leafNodes = 0;
    int start = GetTimeMs();
    S_MOVELIST list[1];
    GenerateAllMoves(pos, list);

    int move;
    int MoveNum = 0;
    for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {
        move = list->moves[MoveNum].move;
        if (!MakeMove(pos, move)) {
            continue;
        }
        long cumnodes = leafNodes;
        Perft(depth - 1, pos);
        TakeMove(pos);
        long oldnodes = leafNodes - cumnodes;
        printf(\"move %d : %s : %ld\\n\", MoveNum + 1, PrMove(move), oldnodes);
    }

    printf(\"\\nTest Complete : %ld nodes visited in %dms\\n\", leafNodes, \
GetTimeMs() - start);

    return;
}\
\>", "Text",
 CellChangeTimes->{
  3.859760427108878*^9, {3.860241472852162*^9, 
   3.860241481444908*^9}},ExpressionUUID->"fdd6fdcb-a2d7-465a-b6bf-\
31c37ae62385"]
}, Closed]],

Cell[CellGroupData[{

Cell["Parsing a move from user / GUI", "Section",
 CellChangeTimes->{{3.8597583911086397`*^9, 3.859758397472293*^9}, {
  3.8597615610934896`*^9, 
  3.859761571310349*^9}},ExpressionUUID->"de0b4088-b7f1-4c7f-82b1-\
e58217b43293"],

Cell["#define NOMOVE 0", "Text",
 CellChangeTimes->{
  3.8597614434678707`*^9},ExpressionUUID->"2ac1cc93-42bd-4449-b826-\
e4f1433bc021"],

Cell["\<\
int ParseMove(char* ptrChar, S_BOARD* pos) {

    if (ptrChar[1] > \[OpenCurlyQuote]8\[CloseCurlyQuote] || ptrChar[1] < \
\[OpenCurlyQuote]1\[CloseCurlyQuote]) return NOMOVE;
    if (ptrChar[3] > \[OpenCurlyQuote]8\[CloseCurlyQuote] || ptrChar[3] < \
\[OpenCurlyQuote]1\[CloseCurlyQuote]) return NOMOVE;
    if (ptrChar[0] > \[OpenCurlyQuote]h\[CloseCurlyQuote] || ptrChar[0] < \
\[OpenCurlyQuote]a\[CloseCurlyQuote]) return NOMOVE;
    if (ptrChar[2] > \[OpenCurlyQuote]h\[CloseCurlyQuote] || ptrChar[2] < \
\[OpenCurlyQuote]a\[CloseCurlyQuote]) return NOMOVE;

    int from = FR2SQ(ptrChar[0] - \[OpenCurlyQuote]a\[CloseCurlyQuote], \
ptrChar[1] - \[OpenCurlyQuote]1\[CloseCurlyQuote]);
    int to = FR2SQ(ptrChar[2] - \[OpenCurlyQuote]a\[CloseCurlyQuote], \
ptrChar[3] - \[OpenCurlyQuote]1\[CloseCurlyQuote]);

    S_MOVELIST list[1];
    GenerateAllMoves(pos, list);
    int MoveNum = 0;
    int Move = 0;
    int PromPce = e;

    for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {
        Move = list->moves[MoveNum].move;
        if (FROMSQ(Move) == from && TOSQ(Move) == to) {
            PromPce = PROMOTED(Move);
            if (PromPce != e) {
                if (IsRQ(PromPce) && !IsBQ(PromPce) && ptrChar[4] == \
\[OpenCurlyQuote]r\[CloseCurlyQuote]) {
                    return Move;
                }
                else if (!IsRQ(PromPce) && IsBQ(PromPce) && ptrChar[4] == \
\[OpenCurlyQuote]b\[CloseCurlyQuote]) {
                    return Move;
                }
                else if (IsRQ(PromPce) && IsBQ(PromPce) && ptrChar[4] == \
\[OpenCurlyQuote]q\[CloseCurlyQuote]) {
                    return Move;
                }
                else if (IsKn(PromPce) && ptrChar[4] == \[OpenCurlyQuote]n\
\[CloseCurlyQuote]) {
                    return Move;
                }
                continue;
            }
            return Move;
        }
    }

    return NOMOVE;
}

void PrintMoveList(const S_MOVELIST* list) {
    int index = 0;
    int score = 0;
    int move = 0;
    printf(\[OpenCurlyDoubleQuote]MoveList:\\n\[CloseCurlyDoubleQuote], \
list->count);

    for (index = 0; index < list->count; ++index) {

        move = list->moves[index].move;
        score = list->moves[index].score;

        printf(\[OpenCurlyDoubleQuote]Move:%d > %s (score:%d)\\n\
\[CloseCurlyDoubleQuote], index + 1, PrMove(move), score);
    }
    printf(\[OpenCurlyDoubleQuote]MoveList Total %d Moves:\\n\\n\
\[CloseCurlyDoubleQuote], list->count);
}\
\>", "Text",
 CellChangeTimes->{
  3.859761537419508*^9},ExpressionUUID->"285f1bbc-65ae-4962-9f72-\
3b73271f4a0d"]
}, Closed]],

Cell[CellGroupData[{

Cell["Repetition Detection", "Section",
 CellChangeTimes->{{3.859827078634136*^9, 
  3.8598270903280783`*^9}},ExpressionUUID->"758dca74-3a8b-4026-adfc-\
e158d74ca387"],

Cell["\<\
static int IsRepetition(const S_BOARD* pos) {

    int index = 0;

    for (index = pos->hisPly - pos->fiftyMove; index < pos->hisPly - 1; \
++index) {
        if (pos->posKey == pos->history[index].posKey) {
            return TRUE;
        }
    }
    return FALSE;
}\
\>", "Text",
 CellChangeTimes->{
  3.859827111055703*^9},ExpressionUUID->"8555d2fe-a816-43d2-8226-\
db0d259a9a3d"]
}, Closed]],

Cell[CellGroupData[{

Cell["Getting the Time in Milliseconds", "Section",
 CellChangeTimes->{{3.86025315046522*^9, 
  3.860253183496662*^9}},ExpressionUUID->"fd0386ea-2d9e-4a6f-948a-\
a1b64f6dcde6"],

Cell["\<\
int GetTimeMs() {
    return GetTickCount();
}\
\>", "Text",
 CellChangeTimes->{
  3.8602531662963543`*^9},ExpressionUUID->"28dceec8-c7c3-4bec-bc6a-\
5ce0201931c6"]
}, Closed]],

Cell[CellGroupData[{

Cell["Principal Variation Table", "Section",
 CellChangeTimes->{{3.85982721568367*^9, 
  3.85982722915765*^9}},ExpressionUUID->"1d275da5-2e04-44dd-adda-\
166229729898"],

Cell["\<\
Extracting the best line found by the program to the given search depth. This \
can later be extended into a transposition table which can speed up the \
search.\
\>", "Text",
 CellChangeTimes->{{3.859827438781047*^9, 3.859827468032095*^9}, {
  3.859923979555134*^9, 
  3.859924032487194*^9}},ExpressionUUID->"d214428c-7f14-4708-a5fc-\
c77666bdbc70"],

Cell["We need some new structures:", "Text",
 CellChangeTimes->{{3.859924170502062*^9, 
  3.859924183405813*^9}},ExpressionUUID->"59bac90e-2d98-406a-8aad-\
86c6ece2da2e"],

Cell["\<\
The entries which will be present in the PVTABLE...it is a pair of the posKey \
and the move which will be stored in the principal variation table. When a \
move is found in the search that beats alpha - store the move and a unique \
key for the position that lead to that move\
\>", "Text",
 CellChangeTimes->{{3.859924190020829*^9, 3.859924215172078*^9}, {
  3.859924299732665*^9, 
  3.859924388491284*^9}},ExpressionUUID->"f819dd95-0928-4cd0-a376-\
8031966cf926"],

Cell["\<\
typedef struct {
    U64 posKey;
    int move;
} S_PVENTRY;\
\>", "CodeText",
 CellChangeTimes->{{3.859924190020829*^9, 
  3.859924230380125*^9}},ExpressionUUID->"c891e781-ab9b-4c5d-905b-\
0b6f93bd30fa"],

Cell["\<\
The actual PVTABLE structure which stores the entries array. A pointer which \
points to an element and a number of entries. We will initialize an amount of \
memory for the number of entries we want to store. We will eventually want to \
dynamically change its size when it becomes a transposition table. This \
method allows us to free the memory and reallocate memory.\
\>", "Text",
 CellChangeTimes->{{3.859924190020829*^9, 3.859924232842209*^9}, {
  3.859924439410084*^9, 3.859924539689344*^9}, {3.8599245815221577`*^9, 
  3.85992469978026*^9}},ExpressionUUID->"5bebba1a-805f-4adf-84cf-\
e099243b8d6c"],

Cell["\<\
typedef struct {
    S_PVENTRY* pTable;
    int numEntries;
} S_PVTABLE;\
\>", "CodeText",
 CellChangeTimes->{{3.859924190020829*^9, 
  3.8599242226819696`*^9}},ExpressionUUID->"d6b8b547-f07f-448a-b728-\
ecda99c3eb67"],

Cell["\<\
Next we make another declaration inside the S_BOARD structure. We make it a \
pointer in this manner - an array with 1 entry.\
\>", "Text",
 CellChangeTimes->{{3.8599247343631687`*^9, 3.8599247662548*^9}, {
  3.859924811680513*^9, 3.859924811867593*^9}, {3.859924848346946*^9, 
  3.8599248808181047`*^9}},ExpressionUUID->"c1cc528b-e9bd-40c5-b8c4-\
f259f0411192"],

Cell["S_PVTABLE PvTable[1];", "CodeText",
 CellChangeTimes->{
  3.859924792026169*^9},ExpressionUUID->"fec65ea4-1684-4a38-a8cc-\
3d263fda9a25"],

Cell["Code to initialize our PV table - 128 MB", "Text",
 CellChangeTimes->{{3.859925015038039*^9, 3.859925030305769*^9}, {
  3.859925227663645*^9, 
  3.8599252319282846`*^9}},ExpressionUUID->"51eea0b3-4734-4ff6-aaef-\
63d71025911d"],

Cell["const int PvSize = 0x100000 * 128;", "CodeText",
 CellChangeTimes->{{3.8599250365291452`*^9, 3.859925049834655*^9}, {
  3.8599250847084312`*^9, 
  3.859925091277767*^9}},ExpressionUUID->"d6a14e81-4260-4c19-9c56-\
4ad8b1e5a896"],

Cell["This function is for initializing the count", "Text",
 CellChangeTimes->{{3.8599250365291452`*^9, 3.859925049834655*^9}, {
  3.8599250847084312`*^9, 
  3.859925115392473*^9}},ExpressionUUID->"31c5664c-5644-4a92-b15d-\
32096e5235b0"],

Cell["\<\
void InitPvTable(S_PVTABLE* table) {

    table->numEntries = PvSize / sizeof(S_PVENTRY);
    table->numEntries -= 2; // to make sure we do not go over the end
    if (table->pTable != NULL) free(table->pTable); // if we initialize \
again, this would free the memory being pointed to
    table->pTable = (S_PVENTRY*)malloc(table->numEntries * \
sizeof(S_PVENTRY)); // here is memory is allocated and declared a pointer \
type
    // we have declared an array like this table->pTable[table->numEntries]
    ClearPvTable(table); // this will set all keys and moves to 0.
    printf(\"PvTable init complete with %d entries\\n\", table->numEntries);

}\
\>", "CodeText",
 CellChangeTimes->{{3.8599250365291452`*^9, 3.859925049834655*^9}, {
  3.8599250847084312`*^9, 3.859925110422408*^9}, {3.859925569642284*^9, 
  3.8599255914993258`*^9}, {3.859925638433632*^9, 3.859925669957279*^9}, {
  3.859926115739191*^9, 3.859926141887374*^9}, {3.859926215072049*^9, 
  3.859926257264636*^9}, {3.859926499899482*^9, 3.859926512754485*^9}, {
  3.859926554800519*^9, 
  3.859926572337378*^9}},ExpressionUUID->"bb57044b-08a6-4d84-a743-\
427f94c28742"],

Cell["\<\
This function is used to reset the Pvtable by setting everything to 0 and \
clear the pvtable for use before the next search is applied\
\>", "Text",
 CellChangeTimes->{{3.8599250365291452`*^9, 3.859925049834655*^9}, {
  3.8599250847084312`*^9, 
  3.859925094595355*^9}},ExpressionUUID->"3ce625b8-22fc-43b8-80a2-\
eace274520f3"],

Cell["\<\
void ClearPvTable(S_PVTABLE* table) {

    S_PVENTRY* pvEntry; // make a pointer to the table and loop through every \
entry in the table

    for (pvEntry = table->pTable; pvEntry < table->pTable + \
table->numEntries; pvEntry++) { // set pointer to the start of the table, \
keep going until we are up to the size of the number of entries, incrementing \
the pointer each time
        pvEntry->posKey = 0ULL;
        pvEntry->move = NOMOVE;
    }
}\
\>", "CodeText",
 CellChangeTimes->{{3.8599250365291452`*^9, 3.859925049834655*^9}, {
  3.8599250847084312`*^9, 3.8599251014609137`*^9}, {3.859926649870613*^9, 
  3.859926686791419*^9}, {3.859926718141341*^9, 3.859926732332365*^9}, {
  3.8599268041902323`*^9, 
  3.8599268795574417`*^9}},ExpressionUUID->"1fb1021d-1663-4932-8528-\
9a9711adc104"],

Cell["We add this to our SetBoard function", "Text",
 CellChangeTimes->{{3.8599270222680073`*^9, 
  3.8599270406065903`*^9}},ExpressionUUID->"88e80914-6f1c-4841-9d22-\
b664263ef5df"],

Cell["InitPvTable(pos->PvTable);", "CodeText",
 CellChangeTimes->{{3.859927047016738*^9, 
  3.859927067022602*^9}},ExpressionUUID->"91fef5c9-7bed-48f6-b500-\
b2baf50839cc"],

Cell["\<\
To store a move in the pvtable using hashing function as poskey%count\
\>", "Text",
 CellChangeTimes->{
  3.859827264154004*^9, {3.859922632066736*^9, 3.859922674732088*^9}, {
   3.8599276391478653`*^9, 
   3.8599276667963743`*^9}},ExpressionUUID->"36bc2336-2940-4a5a-93f3-\
65f097700cc3"],

Cell["\<\
void StorePvMove(const S_BOARD* pos, const int move) {

    int index = pos->posKey % pos->PvTable->numEntries; // this gives a \
number between 0 and numEntries-1

    pos->PvTable->pTable[index].move = move;  // at the position of index \
store the move and the key
    pos->PvTable->pTable[index].posKey = pos->posKey;
}\
\>", "CodeText",
 CellChangeTimes->{
  3.859827264154004*^9, {3.859922632066736*^9, 3.859922671562467*^9}, 
   3.859927751720867*^9, {3.8599280377860193`*^9, 3.8599280677206497`*^9}, {
   3.859928107373166*^9, 3.859928132044168*^9}, {3.8599281735330877`*^9, 
   3.859928202479826*^9}},ExpressionUUID->"f692e4a9-f839-48ce-9ba0-\
c5030a9223f9"],

Cell["\<\
int ProbePvTable(const S_BOARD* pos) {

    int index = pos->posKey % pos->PvTable->numEntries;

    if (pos->PvTable->pTable[index].posKey == pos->posKey) { // do the keys \
match? If so, we can return the move at that index, because we stored it with \
this key
        return pos->PvTable->pTable[index].move;
    }

    return NOMOVE;
}\
\>", "CodeText",
 CellChangeTimes->{
  3.859827264154004*^9, {3.859922632066736*^9, 3.859922671562467*^9}, 
   3.859927754477662*^9, {3.8599283324195137`*^9, 
   3.859928410649952*^9}},ExpressionUUID->"087766be-4ed2-49e4-be1b-\
c384cb5f4244"],

Cell["\<\
Two different keys modulo the number of entries could give the same number. \
We will deal with that when we come to retrieve the principal variation from \
the table.\
\>", "Text",
 CellChangeTimes->{{3.8599285173568277`*^9, 
  3.859928623134983*^9}},ExpressionUUID->"ae7d0a76-bf08-4cfd-be5e-\
f793a4577b7f"],

Cell["Add to S_BOARD:", "Text",
 CellChangeTimes->{{3.859928864113258*^9, 
  3.8599288944273243`*^9}},ExpressionUUID->"11583d22-bb48-4697-8359-\
e126aec6b464"],

Cell["int PvArray[MAXDEPTH];", "CodeText",
 CellChangeTimes->{{3.859928874969714*^9, 
  3.859928890422841*^9}},ExpressionUUID->"436a00a9-2305-41dd-9985-\
551bc5780415"],

Cell["\<\
To get our array out of the table and into the array before printing it to \
the screen. Probe for a move, if we get one make it, probe for another, make \
it.. walk through the best variation the program has found. An illegal move \
could have been saved into the table, so we need a function to test whether a \
move actually exists\
\>", "Text",
 CellChangeTimes->{{3.859928966332535*^9, 
  3.859929216630602*^9}},ExpressionUUID->"5358a2c8-e260-4433-8148-\
5a0eb497ede6"],

Cell["\<\
int MoveExists(S_BOARD* pos, const int move) {

    S_MOVELIST list[1];
    GenerateAllMoves(pos, list);

    int MoveNum = 0;
    for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {

        if (!MakeMove(pos, list->moves[MoveNum].move)) {
            continue;
        }
        TakeMove(pos);
        if (list->moves[MoveNum].move == move) {
            return TRUE;
        }
    }
    return FALSE;
}\
\>", "CodeText",
 CellChangeTimes->{{3.859929304634674*^9, 3.85992931296847*^9}, 
   3.8599294233414516`*^9},ExpressionUUID->"d24d74c9-df5f-487e-92c9-\
653188cb2ecb"],

Cell["\<\
At the end of every search, we call a function which fills the PvArray up to \
MaxDepth with the moves from the table.\
\>", "Text",
 CellChangeTimes->{{3.859929428971084*^9, 
  3.859929524539235*^9}},ExpressionUUID->"17771134-7b21-42b6-b082-\
02b701b7800b"],

Cell["\<\
Get the best pvline stored in the PvArray for a given depth but we may also \
get a result greater than the depth\
\>", "Text",
 CellChangeTimes->{
  3.859827264154004*^9, {3.859922632066736*^9, 3.85992263923216*^9}, 
   3.85992824831465*^9},ExpressionUUID->"b7b8e206-c870-4d55-9fa4-\
74e15aa1cf11"],

Cell["\<\
int GetPvLine(const int depth, S_BOARD* pos) {

    int move = ProbePvTable(pos);
    int count = 0;

    while (move != NOMOVE && count < depth) {

        if (MoveExists(pos, move)) {
            MakeMove(pos, move);
            pos->PvArray[count++] = move;
        }
        else {
            break;
        }
        move = ProbePvTable(pos);
    }

    while (pos->ply > 0) {
        TakeMove(pos);
    }

    return count;

}\
\>", "CodeText",
 CellChangeTimes->{
  3.859827264154004*^9, {3.859922632066736*^9, 3.859922654259453*^9}, 
   3.859927656682391*^9},ExpressionUUID->"4c766da8-9803-465f-8da2-\
74607422e783"]
}, Closed]],

Cell[CellGroupData[{

Cell["Preparation for Search", "Section",
 CellChangeTimes->{{3.86025327431026*^9, 
  3.860253285653117*^9}},ExpressionUUID->"90954c09-51c7-473b-a2c5-\
f6d3695ec7d4"],

Cell["This will hold information we need for the search.", "Text",
 CellChangeTimes->{{3.860253575657069*^9, 
  3.8602535942048073`*^9}},ExpressionUUID->"5e057804-94eb-4917-ab49-\
f2e8bdb19b9d"],

Cell["\<\
typedef struct {

    int starttime;
    int stoptime;
    int depth;
    int timeset;
    int movestogo;

    long nodes;

    int quit;
    int stopped;

    float fh;
    float fhf;

} S_SEARCHINFO;\
\>", "Text",
 CellChangeTimes->{
  3.8602533665315237`*^9},ExpressionUUID->"f3357b39-f3df-4e01-a53e-\
c79976a8b48d"]
}, Closed]],

Cell[CellGroupData[{

Cell["Evaluation", "Section",
 CellChangeTimes->{{3.8597583752365522`*^9, 
  3.859758379855057*^9}},ExpressionUUID->"613e6538-7d74-4f8b-93f2-\
0f921b519675"],

Cell["\<\
const int PawnIsolated = -10;
const int PawnPassed[8] = { 0, 5, 10, 20, 35, 60, 100, 200 };
const int RookOpenFile = 10;
const int RookSemiOpenFile = 5;
const int QueenOpenFile = 5;
const int QueenSemiOpenFile = 3;
const int BishopPair = 30;

const int PawnTable[64] = {
0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,
10\t,\t10\t,\t0\t,\t-10\t,\t-10\t,\t0\t,\t10\t,\t10\t,
5\t,\t0\t,\t0\t,\t5\t,\t5\t,\t0\t,\t0\t,\t5\t,
0\t,\t0\t,\t10\t,\t20\t,\t20\t,\t10\t,\t0\t,\t0\t,
5\t,\t5\t,\t5\t,\t10\t,\t10\t,\t5\t,\t5\t,\t5\t,
10\t,\t10\t,\t10\t,\t20\t,\t20\t,\t10\t,\t10\t,\t10\t,
20\t,\t20\t,\t20\t,\t30\t,\t30\t,\t20\t,\t20\t,\t20\t,
0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0
};

const int KnightTable[64] = {
0\t,\t-10\t,\t0\t,\t0\t,\t0\t,\t0\t,\t-10\t,\t0\t,
0\t,\t0\t,\t0\t,\t5\t,\t5\t,\t0\t,\t0\t,\t0\t,
0\t,\t0\t,\t10\t,\t10\t,\t10\t,\t10\t,\t0\t,\t0\t,
0\t,\t0\t,\t10\t,\t20\t,\t20\t,\t10\t,\t5\t,\t0\t,
5\t,\t10\t,\t15\t,\t20\t,\t20\t,\t15\t,\t10\t,\t5\t,
5\t,\t10\t,\t10\t,\t20\t,\t20\t,\t10\t,\t10\t,\t5\t,
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0\t,
0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0
};

const int BishopTable[64] = {
0\t,\t0\t,\t-10\t,\t0\t,\t0\t,\t-10\t,\t0\t,\t0\t,
0\t,\t0\t,\t0\t,\t10\t,\t10\t,\t0\t,\t0\t,\t0\t,
0\t,\t0\t,\t10\t,\t15\t,\t15\t,\t10\t,\t0\t,\t0\t,
0\t,\t10\t,\t15\t,\t20\t,\t20\t,\t15\t,\t10\t,\t0\t,
0\t,\t10\t,\t15\t,\t20\t,\t20\t,\t15\t,\t10\t,\t0\t,
0\t,\t0\t,\t10\t,\t15\t,\t15\t,\t10\t,\t0\t,\t0\t,
0\t,\t0\t,\t0\t,\t10\t,\t10\t,\t0\t,\t0\t,\t0\t,
0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0\t,\t0
};

const int RookTable[64] = {
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0\t,
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0\t,
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0\t,
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0\t,
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0\t,
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0\t,
25\t,\t25\t,\t25\t,\t25\t,\t25\t,\t25\t,\t25\t,\t25\t,
0\t,\t0\t,\t5\t,\t10\t,\t10\t,\t5\t,\t0\t,\t0
};

const int KingE[64] = {
    -50\t,\t-10\t,\t0\t,\t0\t,\t0\t,\t0\t,\t-10\t,\t-50\t,
    -10,\t0\t,\t10\t,\t10\t,\t10\t,\t10\t,\t0\t,\t-10\t,
    0\t,\t10\t,\t20\t,\t20\t,\t20\t,\t20\t,\t10\t,\t0\t,
    0\t,\t10\t,\t20\t,\t40\t,\t40\t,\t20\t,\t10\t,\t0\t,
    0\t,\t10\t,\t20\t,\t40\t,\t40\t,\t20\t,\t10\t,\t0\t,
    0\t,\t10\t,\t20\t,\t20\t,\t20\t,\t20\t,\t10\t,\t0\t,
    -10,\t0\t,\t10\t,\t10\t,\t10\t,\t10\t,\t0\t,\t-10\t,
    -50\t,\t-10\t,\t0\t,\t0\t,\t0\t,\t0\t,\t-10\t,\t-50
};

const int KingO[64] = {
    0\t,\t5\t,\t5\t,\t-10\t,\t-10\t,\t0\t,\t10\t,\t5\t,
    -30\t,\t-30\t,\t-30\t,\t-30\t,\t-30\t,\t-30\t,\t-30\t,\t-30\t,
    -50\t,\t-50\t,\t-50\t,\t-50\t,\t-50\t,\t-50\t,\t-50\t,\t-50\t,
    -70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,
    -70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,
    -70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,
    -70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,
    -70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70\t,\t-70
};

int MaterialDraw(const S_BOARD* pos) {
    if (!pos->pceNum[R] && !pos->pceNum[r] && !pos->pceNum[Q] && \
!pos->pceNum[q]) {
        if (!pos->pceNum[b] && !pos->pceNum[B]) {
            if (pos->pceNum[N] < 3 && pos->pceNum[n] < 3) { return TRUE; }
        }
        else if (!pos->pceNum[N] && !pos->pceNum[n]) {
            if (abs(pos->pceNum[B] - pos->pceNum[b]) < 2) { return TRUE; }
        }
        else if ((pos->pceNum[N] < 3 && !pos->pceNum[B]) || (pos->pceNum[B] \
== 1 && !pos->pceNum[N])) {
            if ((pos->pceNum[n] < 3 && !pos->pceNum[b]) || (pos->pceNum[b] == \
1 && !pos->pceNum[n])) { return TRUE; }
        }
    }
    else if (!pos->pceNum[Q] && !pos->pceNum[q]) {
        if (pos->pceNum[R] == 1 && pos->pceNum[r] == 1) {
            if ((pos->pceNum[N] + pos->pceNum[B]) < 2 && (pos->pceNum[n] + \
pos->pceNum[b]) < 2) { return TRUE; }
        }
        else if (pos->pceNum[R] == 1 && !pos->pceNum[r]) {
            if ((pos->pceNum[N] + pos->pceNum[B] == 0) && (((pos->pceNum[n] + \
pos->pceNum[b]) == 1) || ((pos->pceNum[n] + pos->pceNum[b]) == 2))) { return \
TRUE; }
        }
        else if (pos->pceNum[r] == 1 && !pos->pceNum[R]) {
            if ((pos->pceNum[n] + pos->pceNum[b] == 0) && (((pos->pceNum[N] + \
pos->pceNum[B]) == 1) || ((pos->pceNum[N] + pos->pceNum[B]) == 2))) { return \
TRUE; }
        }
    }
    return FALSE;
}

#define ENDGAME_MAT (1 * PieceVal[R] + 2 * PieceVal[N] + 2 * PieceVal[P] + \
PieceVal[K])

int EvalPosition(const S_BOARD* pos) {

    int pce;
    int pceNum;
    int sq;
    int score = pos->material[WHITE] - pos->material[BLACK];

    if (!pos->pceNum[P] && !pos->pceNum[p] && MaterialDraw(pos) == TRUE) {
        return 0;
    }

    pce = P;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score += PawnTable[sq];


        if ((IsolatedMask[sq] & pos->pawns[WHITE]) == 0) {
            score += PawnIsolated;
        }

        if ((WhitePassedMask[sq] & pos->pawns[BLACK]) == 0) {
            score += PawnPassed[RanksBrd[sq]];
        }

    }

    pce = p;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score -= PawnTable[MIRROR64(sq)];

        if ((IsolatedMask[sq] & pos->pawns[BLACK]) == 0) {
            score -= PawnIsolated;
        }

        if ((BlackPassedMask[sq] & pos->pawns[WHITE]) == 0) {
            score -= PawnPassed[7 - RanksBrd[sq]];
        }
    }

    pce = N;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score += KnightTable[sq];
    }

    pce = n;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score -= KnightTable[MIRROR64(sq)];
    }

    pce = B;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score += BishopTable[sq];
    }

    pce = b;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score -= BishopTable[MIRROR64(sq)];
    }

    pce = R;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score += RookTable[sq];
        if (!(pos->pawns[BOTH] & FileBBMask[FilesBrd[sq]])) {
            score += RookOpenFile;
        }
        else if (!(pos->pawns[WHITE] & FileBBMask[FilesBrd[sq]])) {
            score += RookSemiOpenFile;
        }
    }

    pce = r;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        score -= RookTable[MIRROR64(sq)];
        if (!(pos->pawns[BOTH] & FileBBMask[FilesBrd[sq]])) {
            score -= RookOpenFile;
        }
        else if (!(pos->pawns[BLACK] & FileBBMask[FilesBrd[sq]])) {
            score -= RookSemiOpenFile;
        }
    }

    pce = Q;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        if (!(pos->pawns[BOTH] & FileBBMask[FilesBrd[sq]])) {
            score += QueenOpenFile;
        }
        else if (!(pos->pawns[WHITE] & FileBBMask[FilesBrd[sq]])) {
            score += QueenSemiOpenFile;
        }
    }

    pce = q;
    for (pceNum = 0; pceNum < pos->pceNum[pce]; ++pceNum) {
        sq = pos->pList[pce][pceNum];
        if (!(pos->pawns[BOTH] & FileBBMask[FilesBrd[sq]])) {
            score -= QueenOpenFile;
        }
        else if (!(pos->pawns[BLACK] & FileBBMask[FilesBrd[sq]])) {
            score -= QueenSemiOpenFile;
        }
    }
    
    pce = K;
    sq = pos->pList[pce][0];

    if ((pos->material[BLACK] <= ENDGAME_MAT)) {
        score += KingE[sq];
    }
    else {
        score += KingO[sq];
    }

    pce = k;
    sq = pos->pList[pce][0];

    if ((pos->material[WHITE] <= ENDGAME_MAT)) {
        score -= KingE[MIRROR64(sq)];
    }
    else {
        score -= KingO[MIRROR64(sq)];
    }

    if (pos->pceNum[B] >= 2) score += BishopPair;
    if (pos->pceNum[b] >= 2) score -= BishopPair;

    if (pos->side == WHITE) {
        return score;
    }
    else {
        return -score;
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859760079951337*^9},ExpressionUUID->"57f76675-1fd1-4aad-b1a4-\
bf77c0b1d1fb"]
}, Closed]],

Cell[CellGroupData[{

Cell["Clear for Search", "Section",
 CellChangeTimes->{{3.860253640485989*^9, 
  3.8602536458661127`*^9}},ExpressionUUID->"a6103b41-8de3-412e-9e23-\
442b33cbb60f"],

Cell["\<\
static void ClearForSearch(S_BOARD* pos, S_SEARCHINFO* info) {

    int index = 0;
    int index2 = 0;

    for (index = 0; index < 13; ++index) {
        for (index2 = 0; index2 < BRD_SQ_NUM; ++index2) {
            pos->searchHistory[index][index2] = 0;
        }
    }

    for (index = 0; index < 2; ++index) {
        for (index2 = 0; index2 < MAXDEPTH; ++index2) {
            pos->searchKillers[index][index2] = 0;
        }
    }

    ClearPvTable(pos->PvTable);
    pos->ply = 0;

    info->stopped = 0;
    info->nodes = 0;
    info->fh = 0;
    info->fhf = 0;
}\
\>", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, {
   3.860253664215657*^9, 
   3.860253679626534*^9}},ExpressionUUID->"f3599389-46d2-490b-80ea-\
6df0f609792a"]
}, Closed]],

Cell[CellGroupData[{

Cell["Iterative Deepening", "Section",
 CellChangeTimes->{{3.859758384835409*^9, 3.859758387709502*^9}, {
   3.860253990466711*^9, 3.860253993244637*^9}, 
   3.860360250922159*^9},ExpressionUUID->"a1238f50-0188-43aa-834c-\
58d5979cf434"],

Cell["\<\
int absoluteValue(int i)
{
    if (i > 0)
    {
        return i;
    }
    else
    {
        return -i;
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, {
   3.8602537186620417`*^9, 
   3.8602537338954277`*^9}},ExpressionUUID->"e63f5e97-5d6b-48fd-b0dc-\
857fc486355b"],

Cell["\<\
SearchPosition allows for good time management. Search to depth 1, is there \
time to search to depth 2, etc. Have a best move returned before the time \
runs out. After each depth search, have the best line found for the previous \
depth. Use this inside the AlphaBeta function for the new depth search and \
for AlphaBeta move ordering is critical. Info held in the principal \
variation, search history and killer heuristic from previous iterations \
greatly improves the move ordering and therefore greatly improves the \
performance of the AlphaBeta function so ends up searching far fewer nodes \
going iteratively through the depths rather than just searching to a \
specified depth.\
\>", "Text",
 CellChangeTimes->{{3.860360417581748*^9, 
  3.860360824198616*^9}},ExpressionUUID->"38537598-d97d-4022-816c-\
d4fb6f7bba89"],

Cell["\<\
At the end of each loop in iterative deepening, we get bestMove, bestScore, \
currentDepth, pvMoves and pvNum.\
\>", "Text",
 CellChangeTimes->{{3.860360835340873*^9, 
  3.860360927440166*^9}},ExpressionUUID->"61375a86-9a91-4bf7-8c4c-\
6897031215ec"],

Cell["\<\
void SearchPosition(S_BOARD* pos, S_SEARCHINFO* info) {

    int bestMove = NOMOVE;
    int bestScore = -infinite;
    int currentDepth = 0;
    int pvMoves = 0;
    int pvNum = 0;

    ClearForSearch(pos, info);

    // iterative deepening
    for (currentDepth = 1; currentDepth <= info->depth; ++currentDepth) {
        // alpha\t beta
        rootDepth = currentDepth;
        bestScore = AlphaBeta(-infinite, infinite, currentDepth, pos, info);

        if (info->stopped == TRUE) {
            break;
        }

        pvMoves = GetPvLine(currentDepth, pos);
        bestMove = pos->PvArray[0];

        if (absoluteValue(bestScore) > ISMATE) {
            bestScore = (bestScore > 0 ? infinite - bestScore + 1 : -infinite \
- bestScore) / 2;
            printf(\"info score mate %d depth %d nodes %ld time %d \",
                bestScore, currentDepth, info->nodes, GetTimeMs() - \
info->starttime);
        }
        else{
            printf(\"info score cp %d depth %d nodes %ld time %d \",
                bestScore, currentDepth, info->nodes, GetTimeMs() - \
info->starttime);
        }
        
        pvMoves = GetPvLine(currentDepth, pos);
        printf(\"pv\");
        for (pvNum = 0; pvNum < pvMoves; ++pvNum) {
             printf(\" %s\", PrMove(pos->PvArray[pvNum]));
            }
            printf(\"\\n\");
    }

    printf(\"bestmove %s\\n\", PrMove(bestMove));

}\
\>", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, {
   3.8602537186620417`*^9, 
   3.86025374816894*^9}},ExpressionUUID->"a9a4214c-d293-423e-9625-\
32ade8059ad5"]
}, Closed]],

Cell[CellGroupData[{

Cell["Move Ordering - Setting Up MVV LVA", "Section",
 CellChangeTimes->{{3.860278924519868*^9, 
  3.86027893285565*^9}},ExpressionUUID->"93d0f366-7324-40e2-ac16-\
0b4a3bd2d675"],

Cell["\<\
/*
PV Move
Cap -> MvvLVA
Killers
HistoryScore

*/

For the move ordering method of most valuable victim least valuable attacker \
- example: a pawn captures queen initially make everything to zero so that \
the score of non capture moves remain zero\
\>", "Text",
 CellChangeTimes->{
  3.860279170375723*^9, {3.8602792754771957`*^9, 
   3.860279282466187*^9}},ExpressionUUID->"7e6eb3e2-11c7-495e-88ba-\
0197cadcaf63"],

Cell["\<\
const int VictimScore[13] = { 0, 100, 200, 300, 400, 500, 600, 100, 200, 300, \
400, 500, 600 };
static int MvvLvaScores[13][13];\
\>", "Text",
 CellChangeTimes->{
  3.860279170375723*^9, {3.8602792754771957`*^9, 
   3.8602792862667913`*^9}},ExpressionUUID->"0e689f05-5197-4c8e-9fc7-\
30973c602135"],

Cell["\<\

Move ordering depth 7 results:
16907660 nodes time 8688 no ordering
842385 nodes and time 484 with ordering\
\>", "Text",
 CellChangeTimes->{
  3.860279170375723*^9, {3.8602792754771957`*^9, 
   3.860279297923764*^9}},ExpressionUUID->"b5a1096e-0eec-42a7-92d2-\
8a3c96106e62"],

Cell["\<\

Initialise the MvvLvaScores array for every combination of 2 pieces\
\>", "Text",
 CellChangeTimes->{
  3.860279170375723*^9, {3.8602792754771957`*^9, 
   3.860279305603147*^9}},ExpressionUUID->"893273e5-4481-4d4b-a99f-\
4d4427cbbed6"],

Cell["\<\
void InitMvvLva() {
    int Attacker;
    int Victim;
    for (Attacker = P; Attacker <= k; ++Attacker) {
        for (Victim = P; Victim <= k; ++Victim) {
            MvvLvaScores[Victim][Attacker] = VictimScore[Victim] + 6 - \
(VictimScore[Attacker] / 100);
        }
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.860279170375723*^9, {3.8602792754771957`*^9, 
   3.860279302975864*^9}},ExpressionUUID->"6b4b8112-04b4-4fdd-9e62-\
03c65cf7988e"],

Cell["Put InitMvvLva()  into AllInit().", "Text",
 CellChangeTimes->{{3.860279216663249*^9, 
  3.860279258598288*^9}},ExpressionUUID->"179d2ae4-b999-4f2e-a32f-\
0e2147427c96"]
}, Closed]],

Cell[CellGroupData[{

Cell["Move Ordering - Picking a Move", "Section",
 CellChangeTimes->{
  3.860279464865611*^9},ExpressionUUID->"9886cc69-3c76-4ddd-ad34-\
7314c974720d"],

Cell["\<\
Wherever we are in the move list - moveNum - where we find the best score in \
the remaining moves, we swap the moves around. Just ordering on captures has \
a huge effect.\
\>", "Text",
 CellChangeTimes->{{3.860362780363888*^9, 3.860362820859763*^9}, {
  3.86036285991468*^9, 3.8603628905224943`*^9}, {3.860363166718445*^9, 
  3.860363190571547*^9}},ExpressionUUID->"cf639556-13d8-4d08-b61a-\
a787343be073"],

Cell["\<\
static void PickNextMove(int moveNum, S_MOVELIST* list) {

    S_MOVE temp;
    int index = 0;
    int bestScore = 0;
    int bestNum = moveNum;

    for (index = moveNum; index < list->count; ++index) {
        if (list->moves[index].score > bestScore) {
            bestScore = list->moves[index].score;
            bestNum = index;
        }
    }
    temp = list->moves[moveNum];
    list->moves[moveNum] = list->moves[bestNum];
    list->moves[bestNum] = temp;
}\
\>", "Text",
 CellChangeTimes->{
  3.860279492384556*^9},ExpressionUUID->"0a4bac8e-12da-450d-81f3-\
b7f6bf714e67"]
}, Closed]],

Cell[CellGroupData[{

Cell["Minimax versus AlphaBeta Pruning", "Section",
 CellChangeTimes->{{3.8602749125128098`*^9, 
  3.8602749370513487`*^9}},ExpressionUUID->"5b6de16b-202c-4cdd-89a9-\
b38c96260d7a"],

Cell[CellGroupData[{

Cell["Minimax", "Subsection",
 CellChangeTimes->{{3.831593631706276*^9, 3.831593636052731*^9}},
 TextAlignment->Center,ExpressionUUID->"2b4e2bab-0586-4d2a-8c8d-5aebf1dd2d23"],

Cell[CellGroupData[{

Cell["Depth 2", "Subsubsection",
 CellChangeTimes->{{3.83167680954513*^9, 
  3.831676812068492*^9}},ExpressionUUID->"681e10a5-16f2-4e6c-a090-\
387d78754885"],

Cell["\<\
How the program will search a position. Top starting position white to move. \
Here always just 2 legal moves. Program walks through the tree getting the \
best score to a certain depth. To depth 1, one scores 10, the other 4. White \
wants its score as big as possible, black as small as possible. Black will \
make the reply to White\[CloseCurlyQuote]s move that scores 10, the move that \
scores -20. For White\[CloseCurlyQuote]s move that scores 4, black will make \
the move that scores -14. So when searching to depth 2, white would choose \
the move that would give then a score of -14. White would choose the right \
move.\
\>", "Text",
 CellChangeTimes->{{3.831592982044537*^9, 3.831593076534368*^9}, {
  3.831593118984087*^9, 3.831593174735751*^9}, {3.831593235888102*^9, 
  3.831593539122242*^9}, {3.831593582188365*^9, 3.8315935843698807`*^9}, {
  3.8315954358238277`*^9, 3.831595437665248*^9}, {3.831596008707467*^9, 
  3.831596024650715*^9}},ExpressionUUID->"fa808696-d1bc-4863-ba27-\
906572ad6df6"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TreePlot", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"1", "\[Rule]", "2"}], ",", 
     RowBox[{"3", "\[Rule]", "1"}], ",", 
     RowBox[{"2", "\[Rule]", "4"}], ",", 
     RowBox[{"2", "\[Rule]", "5"}], ",", 
     RowBox[{"3", "->", "6"}], ",", 
     RowBox[{"3", "->", "7"}]}], "}"}], ",", 
   RowBox[{"VertexLabels", "\[Rule]", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"2", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "10"}], "}"}], "]"}]}], ",", 
      RowBox[{"3", "->", "4"}], ",", 
      RowBox[{"4", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<Black \>\"", ",", 
          RowBox[{"-", "20"}]}], "}"}], "]"}]}], ",", 
      RowBox[{"5", "->", 
       RowBox[{"-", "15"}]}], ",", 
      RowBox[{"6", "->", 
       RowBox[{"-", "2"}]}], ",", 
      RowBox[{"7", "->", 
       RowBox[{"-", "14"}]}]}], "}"}]}], ",", 
   RowBox[{"ImageSize", "->", "400"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.831590675206427*^9, 3.831590693737986*^9}, {
  3.831590869610656*^9, 3.831591114113171*^9}, {3.8315955038819237`*^9, 
  3.8315955295739317`*^9}},
 CellLabel->"In[49]:=",
 CellID->1524298092,ExpressionUUID->"19225840-f28d-481c-b74f-93683e13c3b0"],

Cell[BoxData[
 GraphicsBox[{
   {Hue[0.6, 0.7, 0.5], Opacity[0.7], Arrowheads[0.], 
    ArrowBox[{{{1.2247448713915892`, 1.6329931618554523`}, {
     0.4082482904638631, 0.8164965809277261}}, {{1.2247448713915892`, 
     1.6329931618554523`}, {2.041241452319315, 0.8164965809277261}}, {{
     0.4082482904638631, 0.8164965809277261}, {0., 0.}}, {{0.4082482904638631,
      0.8164965809277261}, {0.8164965809277261, 0.}}, {{2.041241452319315, 
     0.8164965809277261}, {1.6329931618554523`, 0.}}, {{2.041241452319315, 
     0.8164965809277261}, {2.4494897427831783`, 0.}}}, 
     0.02615707791054188]}, 
   {Hue[0.6, 0.2, 0.8], EdgeForm[{GrayLevel[0], Opacity[0.7]}], 
    DiskBox[{1.2247448713915892, 1.6329931618554523}, 0.02615707791054188], {
     DiskBox[{0.4082482904638631, 0.8164965809277261}, 0.02615707791054188], 
     InsetBox[
      TemplateBox[{"\"White \"", "10"},
       "RowDefault"], 
      Offset[{2, 2}, {0.43440536837440497, 0.842653658838268}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.041241452319315, 0.8164965809277261}, 0.02615707791054188], 
     InsetBox["4", Offset[{2, 2}, {2.067398530229857, 0.842653658838268}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {DiskBox[{0., 0.}, 0.02615707791054188], 
     InsetBox[
      TemplateBox[{"\"Black \"", 
        RowBox[{"-", "20"}]},
       "RowDefault"], 
      Offset[{2, 2}, {0.02615707791054188, 0.02615707791054188}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.8164965809277261, 0.}, 0.02615707791054188], InsetBox[
      RowBox[{"-", "15"}], 
      Offset[{2, 2}, {0.842653658838268, 0.02615707791054188}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.6329931618554523, 0.}, 0.02615707791054188], InsetBox[
      RowBox[{"-", "2"}], 
      Offset[{2, 2}, {1.659150239765994, 0.02615707791054188}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.4494897427831783, 0.}, 0.02615707791054188], InsetBox[
      RowBox[{"-", "14"}], 
      Offset[{2, 2}, {2.4756468206937203, 0.02615707791054188}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}}},
  FormatType->TraditionalForm,
  FrameTicks->None,
  ImageSize->400]], "Output",
 CellContext->"Cell$$8152`",
 CellChangeTimes->{{3.831590676793336*^9, 3.831590694577814*^9}, 
   3.831590870210814*^9, {3.8315909138674707`*^9, 3.8315909407226686`*^9}, {
   3.8315909770090513`*^9, 3.8315911149719963`*^9}, {3.8315955050357723`*^9, 
   3.831595530380822*^9}},
 GraphicsBoxOptions->{ImageSize->100},
 CellLabel->"Out[49]=",ImageCache->GraphicsData["CompressedBitmap", "\<\
eJztnXmcHUW1x5tZk8xkJ/t2k5CNTIAkJCGEwISQnbAHCCFwQwgkLIZ9FTIs
YRGQHUTgjYA85CEPAXk8BBwWAREQFRFQcQwRUYHnUx8qis6bOqeq+5yaX1UN
61/ezyc3M31/53e+VdVV3V19p2vpqpPWrjl21UnrVq8qLThh1XFr160+sTR/
/Qntmyq3yLLKUpZV9C9lVe0/t2VZ5G10lv1r66e/tS+9V/Zvf5vb/u/ybvU9
sooX+w8cmlXe07tPv5vaty03it+Rrsrp1lutkK63H31K0gbm7cMRhumJEaPH
vdew3Yy2SZN3qGibPH12Vm1+ND+9M27i5Nu7dqunyLeKJGbbq0NHjDZhFUVc
lfnRxTR0PuSNUWO3/hghW3ORetN799U9+2xpPjXatllzFrWd1HRl27Vf/Vbb
bd98nv4/beN1bUuXrTKfm/qhsr1JsTXm50e6dO1G8bvM37PtiOM2tF1wzdcq
THBWQ+Fmk/moPfypnr36NnzS0dQUnY+ewIXvxdW2+5YDBpsGINVRJ59fS8FV
VGYRtJnVDTblO8NHjjHeXazapPmM1OMZv2fR6g8NHDKC2q5d2ZWCKh2+8cve
KKSmV5kmNNJuVtpeaCM1H30MqdntPKlpF5Iq5EpT49Rk7btUVmfl7T8bB9q1
NrHONa9pmaz+w+vyXbWzunEK84Yt+w2iWm3fo3LM9p5h0NcL243tb6ZtSFdf
6Mw+/anoNKYZi2jwad/bc3k79n2Zff2SddRGAwYNa7ui+YGs+2egG6swafcw
mEboMNt/px1U2N7nbI2ie6Hz039iOo2ZdyVTKtfo7TX73viJk28SjZR3DqOr
/2R0VEUhnW50c6gizPb9Isds31/MQLZR2K536Y2u/jPQaUzTq2hs9Xo66pmm
Qd5btM/BVldFo7fQfrJS08HmFrx8LKikbue6vBhJ81bYXLQWadsHucwNeO1j
38fRUbWGdOMlJh0o8uO1OGTZCFc2cVi5z0Xk6mqqCTtIm9OdhuxDhbgzCT+E
mjsRYkvDZx/Vc92u784+2is8k4dwczayaO8VpmhmtDAnYHwCUOuStg4cUnLH
77Zzr7iNgitoRKymbe2fOQI6p/TiaYD4LOPtKUifogZMyfJaaB+fMnvmZsL+
NGyrbTbV9R9nQvlkr9pk/kZVlx5v9+g/8tcDh44WIXQqasKMndl7zBFaxt3k
0hlqL+6DhskzXTo/7kPls2eY4iTf0NMYUUFjfvVN9vdv9Nlq5/vGLt6wfMzi
s226bv1Hzdtw07hFGx4a1bj+lC69hztkU4HmZ3du/raVW3sk+3K/CQuM/dyx
C8/6kO72xH8wl6Fh/JINxsj8s5yVxtT8btyy9/U2pNs4dnFTNpVth/BHZlNe
fN6vqhyg2W7S/k1LjVtIqs0V85uA+e+A+U3AvD3bDgXMmzHIB4A5INXminkz
YP4HYN4MmKex7TDAvAmD/BMwB6TaXDFvAsxtgHkTYJ7OtsMBcysGIectAHhA
rzMo8NYQeAWg98REP4O9RwD61yP0lYA+oNcZFP3rIfoqQO+JiX4H9i4B+r15
G39kXxdGSlQNSvQzrFdZq2SJyu0baqiaK1va35qcylZXY/tbq91uW6ir+dxo
2+y//PP2V7P9zMbXlOw2X2vtm+0mmbIsLXtrDAKtpfdqWU8lp6/kts49zWsj
e6g2GwOKZ+tTIrcffXK/Ruf3A+1HTV0X5NTt+aSOpV0CsXTV28oFXzaS3qtc
sz/RfeBEA1ndmhe/e45qsduyooVKmW6JRvdZBVer+axFxJfEZ80WpUl4uH7r
9ohSsa1K5jI/06kIVSnXTTdZN860BSThJuywW4uay4vIHZF2PNcSEts2qKyh
7EW2UR2pzkPVzfhE53lsS5btNvO/bslq1x1f7Tl8qiepdJUgRshaZZ8VLdxc
FD9vjeYiLt9GZefOVquwsqJfl0AcafpqLtpTumR5DeXbxPiRc5zP21RHHAuq
zJahWW6r1DmoTX6o/WRHdLGU9zmto06H8kaaahS9U6eTzVRDm+tUDWUd+5xz
FC1Uq7Zlul/arN3kyKpaxvPsx+Cq0Wt5W1MmGt1WbKvdRq9zuWT+rhxpl5xS
bHP1TTVg26Vjf/IQn+18arE7lV2aSnqvkk1dzolcixnDji1Wq3gzr8V4v+/e
KrY1ZcUBwGmb0e/cF2plXytlehR0/aUsvLOapqJI7uX1P+pXNXobF5K3uTJR
Dm5W3dcGdDKv9XPlIkVdEZtvE/3vxS3H7WaqOavtZDm+q/moT34cPnFCkY+X
tWCs55NYe3uo8uvd+paM6JSa+gG203UpZUVnc6EylS2Nkbls9rhb6/aYyJ5R
46zdHuH2Qjv4tIqPs5q2vFD5yytoMVzQMdo7bBjj7ByuNL+bDehkwsje0CS3
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
\
\>", "ImageResolution" -> \
144.],ExpressionUUID->"bd23fe48-9478-4dd8-a2dc-32f53a65c969"]
}, {2}]],

Cell["The tree looks like this.", "Text",
 CellChangeTimes->{{3.831676607825848*^9, 
  3.83167661668923*^9}},ExpressionUUID->"8b5de160-cd45-4610-8fd0-\
f97e8b5515a3"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TreePlot", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"1", "\[Rule]", "2"}], ",", 
     RowBox[{"3", "\[Rule]", "1"}], ",", 
     RowBox[{"2", "\[Rule]", "4"}], ",", 
     RowBox[{"2", "\[Rule]", "5"}], ",", 
     RowBox[{"3", "->", "6"}], ",", 
     RowBox[{"3", "->", "7"}]}], "}"}], ",", 
   RowBox[{"VertexLabels", "\[Rule]", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"1", "->", 
       RowBox[{"-", "14"}]}], ",", 
      RowBox[{"2", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", 
          RowBox[{"-", "20"}]}], "}"}], "]"}]}], ",", 
      RowBox[{"3", "->", 
       RowBox[{"-", "14"}]}], ",", 
      RowBox[{"4", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<Black \>\"", ",", 
          RowBox[{"-", "20"}]}], "}"}], "]"}]}], ",", 
      RowBox[{"5", "->", 
       RowBox[{"-", "15"}]}], ",", 
      RowBox[{"6", "->", 
       RowBox[{"-", "2"}]}], ",", 
      RowBox[{"7", "->", 
       RowBox[{"-", "14"}]}]}], "}"}]}], ",", 
   RowBox[{"ImageSize", "->", "400"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.831590675206427*^9, 3.831590693737986*^9}, {
  3.831590869610656*^9, 3.831591114113171*^9}, {3.8315955038819237`*^9, 
  3.8315955295739317`*^9}, {3.831676639524836*^9, 3.8316766408858213`*^9}, {
  3.831676679569539*^9, 3.831676695873467*^9}},
 CellLabel->"In[5]:=",
 CellID->568577340,ExpressionUUID->"b7c96bff-2e08-4608-9db5-9a4537fd3081"],

Cell[BoxData[
 GraphicsBox[{
   {Hue[0.6, 0.7, 0.5], Opacity[0.7], Arrowheads[0.], 
    ArrowBox[{{{1.2247448713915892`, 1.6329931618554523`}, {
     0.4082482904638631, 0.8164965809277261}}, {{1.2247448713915892`, 
     1.6329931618554523`}, {2.041241452319315, 0.8164965809277261}}, {{
     0.4082482904638631, 0.8164965809277261}, {0., 0.}}, {{0.4082482904638631,
      0.8164965809277261}, {0.8164965809277261, 0.}}, {{2.041241452319315, 
     0.8164965809277261}, {1.6329931618554523`, 0.}}, {{2.041241452319315, 
     0.8164965809277261}, {2.4494897427831783`, 0.}}}, 
     0.02615707791054188]}, 
   {Hue[0.6, 0.2, 0.8], EdgeForm[{GrayLevel[0], Opacity[
    0.7]}], {DiskBox[{1.2247448713915892, 1.6329931618554523}, 
      0.02615707791054188], InsetBox[
      RowBox[{"-", "14"}], 
      Offset[{2, 2}, {1.250901949302131, 1.659150239765994}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.4082482904638631, 0.8164965809277261}, 0.02615707791054188], 
     InsetBox[
      TemplateBox[{"\"White \"", 
        RowBox[{"-", "20"}]},
       "RowDefault"], 
      Offset[{2, 2}, {0.43440536837440497, 0.842653658838268}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.041241452319315, 0.8164965809277261}, 0.02615707791054188], 
     InsetBox[
      RowBox[{"-", "14"}], 
      Offset[{2, 2}, {2.067398530229857, 0.842653658838268}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {DiskBox[{0., 0.}, 0.02615707791054188], 
     InsetBox[
      TemplateBox[{"\"Black \"", 
        RowBox[{"-", "20"}]},
       "RowDefault"], 
      Offset[{2, 2}, {0.02615707791054188, 0.02615707791054188}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.8164965809277261, 0.}, 0.02615707791054188], InsetBox[
      RowBox[{"-", "15"}], 
      Offset[{2, 2}, {0.842653658838268, 0.02615707791054188}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.6329931618554523, 0.}, 0.02615707791054188], InsetBox[
      RowBox[{"-", "2"}], 
      Offset[{2, 2}, {1.659150239765994, 0.02615707791054188}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.4494897427831783, 0.}, 0.02615707791054188], InsetBox[
      RowBox[{"-", "14"}], 
      Offset[{2, 2}, {2.4756468206937203, 0.02615707791054188}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}}},
  FormatType->TraditionalForm,
  FrameTicks->None,
  ImageSize->400]], "Output",
 CellChangeTimes->{
  3.83167664664256*^9, {3.8316766815316277`*^9, 3.831676696791766*^9}},
 CellLabel->"Out[5]=",ExpressionUUID->"82ca5c72-34ac-4230-8718-204606f7cf4d"]
}, {2}]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Depth 3", "Subsubsection",
 CellChangeTimes->{{3.831593839890119*^9, 3.8315939932641068`*^9}, {
   3.831594026451724*^9, 3.8315942001512136`*^9}, 3.8315942655352488`*^9, {
   3.831594414016865*^9, 3.8315944430287447`*^9}, 3.8315960370974607`*^9, {
   3.83167682544401*^9, 
   3.8316768260706377`*^9}},ExpressionUUID->"68c99194-72cb-4e0c-96c9-\
5194ae32dca9"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TreePlot", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"1", "\[Rule]", "2"}], ",", 
     RowBox[{"3", "\[Rule]", "1"}], ",", 
     RowBox[{"2", "\[Rule]", "4"}], ",", 
     RowBox[{"2", "\[Rule]", "5"}], ",", 
     RowBox[{"3", "->", "6"}], ",", 
     RowBox[{"3", "->", "7"}], ",", 
     RowBox[{"4", "->", "8"}], ",", 
     RowBox[{"4", "->", "9"}], ",", 
     RowBox[{"5", "->", "10"}], ",", 
     RowBox[{"5", "->", "11"}], ",", 
     RowBox[{"6", "->", "12"}], ",", 
     RowBox[{"6", "->", "13"}], ",", 
     RowBox[{"7", "->", "14"}], ",", 
     RowBox[{"7", "->", "15"}]}], "}"}], ",", 
   RowBox[{"VertexLabels", "\[Rule]", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"2", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "10"}], "}"}], "]"}]}], ",", 
      RowBox[{"3", "->", "4"}], ",", 
      RowBox[{"4", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<Black \>\"", ",", 
          RowBox[{"-", "20"}]}], "}"}], "]"}]}], ",", 
      RowBox[{"5", "->", 
       RowBox[{"-", "15"}]}], ",", 
      RowBox[{"6", "->", 
       RowBox[{"-", "2"}]}], ",", 
      RowBox[{"7", "->", 
       RowBox[{"-", "14"}]}], ",", 
      RowBox[{"8", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "20"}], "}"}], "]"}]}], ",", 
      RowBox[{"9", "->", "2"}], ",", 
      RowBox[{"10", "->", "6"}], ",", 
      RowBox[{"11", "->", "8"}], ",", 
      RowBox[{"12", "->", "12"}], ",", 
      RowBox[{"13", "->", "7"}], ",", 
      RowBox[{"14", "->", 
       RowBox[{"-", "10"}]}], ",", 
      RowBox[{"15", "->", 
       RowBox[{"-", "3"}]}]}], "}"}]}], ",", 
   RowBox[{"ImageSize", "->", "400"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.831590675206427*^9, 3.831590693737986*^9}, {
  3.831590869610656*^9, 3.831591114113171*^9}},
 CellLabel->"In[47]:=",
 CellID->1330103967,ExpressionUUID->"d963b083-0404-43e0-a8df-e787996288e8"],

Cell[BoxData[
 GraphicsBox[{
   {Hue[0.6, 0.7, 0.5], Opacity[0.7], Arrowheads[0.], ArrowBox[CompressedData["
1:eJxTTMoPSmVmYGDgA2ImKA4OWT+z6wyzw82c+2fKfjBA6Q/2Z6zr0+Yt+GaP
Lm/56d2ZmzL8DjB5dPUQ+hqUfoYhv59LnuGYxx+4PLp5bsr+xptKOB1wyU9L
cN/ckCQEl0e3jwENoMujq0N3D8weXPKwcIDJo7sXQrPhlIeYxwOXR/cPxHwB
nPKQ+BCGywMAvrS/KQ==
     "], 0.04275994200999855]}, 
   {Hue[0.6, 0.2, 0.8], EdgeForm[{GrayLevel[0], Opacity[0.7]}], 
    DiskBox[{2.4748737341529163, 2.1213203435596424}, 0.04275994200999855], {
     DiskBox[{1.0606601717798212, 1.414213562373095}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"White \"", "10"},
       "RowDefault"], 
      Offset[{2, 2}, {1.1034201137898196, 1.4569735043830936}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.8890872965260113, 1.414213562373095}, 0.04275994200999855], 
     InsetBox["4", Offset[{2, 2}, {3.93184723853601, 1.4569735043830936}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.35355339059327373, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"Black \"", 
        RowBox[{"-", "20"}]},
       "RowDefault"], Offset[{2, 2}, {0.3963133326032723, 0.749866723196546}],
       ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.7677669529663687, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      RowBox[{"-", "15"}], 
      Offset[{2, 2}, {1.810526894976367, 0.749866723196546}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.181980515339464, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      RowBox[{"-", "2"}], 
      Offset[{2, 2}, {3.2247404573494625, 0.749866723196546}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.596194077712559, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      RowBox[{"-", "14"}], 
      Offset[{2, 2}, {4.638954019722557, 0.749866723196546}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {DiskBox[{0., 0.}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"White \"", "20"},
       "RowDefault"], 
      Offset[{2, 2}, {0.04275994200999855, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.7071067811865475, 0.}, 0.04275994200999855], 
     InsetBox["2", Offset[{2, 2}, {0.749866723196546, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.414213562373095, 0.}, 0.04275994200999855], 
     InsetBox["6", Offset[{2, 2}, {1.4569735043830936, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.1213203435596424, 0.}, 0.04275994200999855], 
     InsetBox["8", Offset[{2, 2}, {2.164080285569641, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.82842712474619, 0.}, 0.04275994200999855], 
     InsetBox["12", Offset[{2, 2}, {2.8711870667561885, 0.04275994200999855}],
       ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.5355339059327373, 0.}, 0.04275994200999855], 
     InsetBox["7", Offset[{2, 2}, {3.578293847942736, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.242640687119285, 0.}, 0.04275994200999855], InsetBox[
      RowBox[{"-", "10"}], 
      Offset[{2, 2}, {4.285400629129283, 0.04275994200999855}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.949747468305833, 0.}, 0.04275994200999855], InsetBox[
      RowBox[{"-", "3"}], 
      Offset[{2, 2}, {4.992507410315831, 0.04275994200999855}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}}},
  FormatType->TraditionalForm,
  FrameTicks->None,
  ImageSize->400]], "Output",
 CellChangeTimes->{3.8315938226058083`*^9},
 CellLabel->"Out[47]=",ExpressionUUID->"3dde7012-1d8d-4ac7-ae94-6010a1c9a16b"]
}, {2}]],

Cell[TextData[{
 "Leftmost, white would choose the move that gives 20 if black chose the move \
that gave -20. Next white would choose the move that would give ",
 "8",
 " if black chose the move that gave -15, so ",
 "black would choose the move that gives -15",
 StyleBox[".",
  FontWeight->"Bold"],
 " Next white would choose the move giving 12 if black chose the move that \
gave -2. White would choose the move that gives ",
 "-3",
 " if black chose the move that gives -14. So ",
 "black would choose the move giving -14",
 ". So white would choose the move that would score 8."
}], "Text",
 CellChangeTimes->{{3.831593839890119*^9, 3.8315939932641068`*^9}, {
   3.831594026451724*^9, 3.8315942001512136`*^9}, 3.8315942655352488`*^9, {
   3.831594414016865*^9, 3.8315944430287447`*^9}, 
   3.831596045576787*^9},ExpressionUUID->"5e79cf24-f2aa-4782-afd1-\
72152c12ca3f"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TreePlot", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"1", "\[Rule]", "2"}], ",", 
     RowBox[{"3", "\[Rule]", "1"}], ",", 
     RowBox[{"2", "\[Rule]", "4"}], ",", 
     RowBox[{"2", "\[Rule]", "5"}], ",", 
     RowBox[{"3", "->", "6"}], ",", 
     RowBox[{"3", "->", "7"}], ",", 
     RowBox[{"4", "->", "8"}], ",", 
     RowBox[{"4", "->", "9"}], ",", 
     RowBox[{"5", "->", "10"}], ",", 
     RowBox[{"5", "->", "11"}], ",", 
     RowBox[{"6", "->", "12"}], ",", 
     RowBox[{"6", "->", "13"}], ",", 
     RowBox[{"7", "->", "14"}], ",", 
     RowBox[{"7", "->", "15"}]}], "}"}], ",", 
   RowBox[{"VertexLabels", "\[Rule]", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"2", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "10"}], "}"}], "]"}]}], ",", 
      RowBox[{"3", "->", "4"}], ",", 
      RowBox[{"4", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<Black \>\"", ",", "20"}], "}"}], "]"}]}], ",", 
      RowBox[{"5", "->", "8"}], ",", 
      RowBox[{"6", "->", "12"}], ",", 
      RowBox[{"7", "->", 
       RowBox[{"-", "3"}]}], ",", 
      RowBox[{"8", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "20"}], "}"}], "]"}]}], ",", 
      RowBox[{"9", "->", "2"}], ",", 
      RowBox[{"10", "->", "6"}], ",", 
      RowBox[{"11", "->", "8"}], ",", 
      RowBox[{"12", "->", "12"}], ",", 
      RowBox[{"13", "->", "7"}], ",", 
      RowBox[{"14", "->", 
       RowBox[{"-", "10"}]}], ",", 
      RowBox[{"15", "->", 
       RowBox[{"-", "3"}]}]}], "}"}]}], ",", 
   RowBox[{"ImageSize", "->", "400"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.831590675206427*^9, 3.831590693737986*^9}, {
  3.831590869610656*^9, 3.831591114113171*^9}, {3.831595768370138*^9, 
  3.8315958040157967`*^9}, {3.831597174778126*^9, 3.831597193212985*^9}},
 CellLabel->"In[88]:=",
 CellID->151803337,ExpressionUUID->"25ba39bc-1c55-42bc-8f8f-b4175e7b98c6"],

Cell[BoxData[
 GraphicsBox[{
   {Hue[0.6, 0.7, 0.5], Opacity[0.7], Arrowheads[0.], ArrowBox[CompressedData["
1:eJxTTMoPSmVmYGDgA2ImKA4OWT+z6wyzw82c+2fKfjBA6Q/2Z6zr0+Yt+GaP
Lm/56d2ZmzL8DjB5dPUQ+hqUfoYhv59LnuGYxx+4PLp5bsr+xptKOB1wyU9L
cN/ckCQEl0e3jwENoMujq0N3D8weXPKwcIDJo7sXQrPhlIeYxwOXR/cPxHwB
nPKQ+BCGywMAvrS/KQ==
     "], 0.04275994200999855]}, 
   {Hue[0.6, 0.2, 0.8], EdgeForm[{GrayLevel[0], Opacity[0.7]}], 
    DiskBox[{2.4748737341529163, 2.1213203435596424}, 0.04275994200999855], {
     DiskBox[{1.0606601717798212, 1.414213562373095}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"White \"", "10"},
       "RowDefault"], 
      Offset[{2, 2}, {1.1034201137898196, 1.4569735043830936}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.8890872965260113, 1.414213562373095}, 0.04275994200999855], 
     InsetBox["4", Offset[{2, 2}, {3.93184723853601, 1.4569735043830936}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.35355339059327373, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"Black \"", "20"},
       "RowDefault"], Offset[{2, 2}, {0.3963133326032723, 0.749866723196546}],
       ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.7677669529663687, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox["8", Offset[{2, 2}, {1.810526894976367, 0.749866723196546}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.181980515339464, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox["12", Offset[{2, 2}, {3.2247404573494625, 0.749866723196546}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.596194077712559, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      RowBox[{"-", "3"}], 
      Offset[{2, 2}, {4.638954019722557, 0.749866723196546}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {DiskBox[{0., 0.}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"White \"", "20"},
       "RowDefault"], 
      Offset[{2, 2}, {0.04275994200999855, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.7071067811865475, 0.}, 0.04275994200999855], 
     InsetBox["2", Offset[{2, 2}, {0.749866723196546, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.414213562373095, 0.}, 0.04275994200999855], 
     InsetBox["6", Offset[{2, 2}, {1.4569735043830936, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.1213203435596424, 0.}, 0.04275994200999855], 
     InsetBox["8", Offset[{2, 2}, {2.164080285569641, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.82842712474619, 0.}, 0.04275994200999855], 
     InsetBox["12", Offset[{2, 2}, {2.8711870667561885, 0.04275994200999855}],
       ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.5355339059327373, 0.}, 0.04275994200999855], 
     InsetBox["7", Offset[{2, 2}, {3.578293847942736, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.242640687119285, 0.}, 0.04275994200999855], InsetBox[
      RowBox[{"-", "10"}], 
      Offset[{2, 2}, {4.285400629129283, 0.04275994200999855}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.949747468305833, 0.}, 0.04275994200999855], InsetBox[
      RowBox[{"-", "3"}], 
      Offset[{2, 2}, {4.992507410315831, 0.04275994200999855}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}}},
  FormatType->TraditionalForm,
  FrameTicks->None,
  ImageSize->400]], "Output",
 CellChangeTimes->{
  3.8315957397689743`*^9, {3.831595782946046*^9, 3.831595805146894*^9}, 
   3.831597177683168*^9, 3.831597831162166*^9},
 CellLabel->"Out[88]=",ExpressionUUID->"d429d03d-d969-414b-8323-12a4f562e5ff"]
}, {2}]],

Cell["\<\
Black would choose the move giving 8 on the left side of the tree and on the \
right black would choose the move giving -3. So white would choose the move \
giving 8.\
\>", "Text",
 CellChangeTimes->{{3.8315961250534153`*^9, 
  3.831596250906631*^9}},ExpressionUUID->"8661ce73-faa3-41b3-aa82-\
f92c50a12adf"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TreePlot", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"1", "\[Rule]", "2"}], ",", 
     RowBox[{"3", "\[Rule]", "1"}], ",", 
     RowBox[{"2", "\[Rule]", "4"}], ",", 
     RowBox[{"2", "\[Rule]", "5"}], ",", 
     RowBox[{"3", "->", "6"}], ",", 
     RowBox[{"3", "->", "7"}], ",", 
     RowBox[{"4", "->", "8"}], ",", 
     RowBox[{"4", "->", "9"}], ",", 
     RowBox[{"5", "->", "10"}], ",", 
     RowBox[{"5", "->", "11"}], ",", 
     RowBox[{"6", "->", "12"}], ",", 
     RowBox[{"6", "->", "13"}], ",", 
     RowBox[{"7", "->", "14"}], ",", 
     RowBox[{"7", "->", "15"}]}], "}"}], ",", 
   RowBox[{"VertexLabels", "\[Rule]", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"1", "->", "8"}], ",", 
      RowBox[{"2", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "8"}], "}"}], "]"}]}], ",", 
      RowBox[{"3", "->", 
       RowBox[{"-", "3"}]}], ",", 
      RowBox[{"4", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<Black \>\"", ",", "20"}], "}"}], "]"}]}], ",", 
      RowBox[{"5", "->", "8"}], ",", 
      RowBox[{"6", "->", "12"}], ",", 
      RowBox[{"7", "->", 
       RowBox[{"-", "3"}]}], ",", 
      RowBox[{"8", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "20"}], "}"}], "]"}]}], ",", 
      RowBox[{"9", "->", "2"}], ",", 
      RowBox[{"10", "->", "6"}], ",", 
      RowBox[{"11", "->", "8"}], ",", 
      RowBox[{"12", "->", "12"}], ",", 
      RowBox[{"13", "->", "7"}], ",", 
      RowBox[{"14", "->", 
       RowBox[{"-", "10"}]}], ",", 
      RowBox[{"15", "->", 
       RowBox[{"-", "3"}]}]}], "}"}]}], ",", 
   RowBox[{"ImageSize", "->", "400"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.831590675206427*^9, 3.831590693737986*^9}, {
  3.831590869610656*^9, 3.831591114113171*^9}, {3.831595768370138*^9, 
  3.8315958040157967`*^9}, {3.8315958456012487`*^9, 3.831595868140648*^9}, {
  3.831597200202979*^9, 3.831597202820806*^9}},
 CellLabel->"In[69]:=",
 CellID->1011930940,ExpressionUUID->"af3984e7-6e06-472a-9385-22be3b7daa9c"],

Cell[BoxData[
 GraphicsBox[{
   {Hue[0.6, 0.7, 0.5], Opacity[0.7], Arrowheads[0.], ArrowBox[CompressedData["
1:eJxTTMoPSmVmYGDgA2ImKA4OWT+z6wyzw82c+2fKfjBA6Q/2Z6zr0+Yt+GaP
Lm/56d2ZmzL8DjB5dPUQ+hqUfoYhv59LnuGYxx+4PLp5bsr+xptKOB1wyU9L
cN/ckCQEl0e3jwENoMujq0N3D8weXPKwcIDJo7sXQrPhlIeYxwOXR/cPxHwB
nPKQ+BCGywMAvrS/KQ==
     "], 0.04275994200999855]}, 
   {Hue[0.6, 0.2, 0.8], EdgeForm[{GrayLevel[0], Opacity[
    0.7]}], {DiskBox[{2.4748737341529163, 2.1213203435596424}, 
      0.04275994200999855], 
     InsetBox["8", Offset[{2, 2}, {2.517633676162915, 2.164080285569641}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.0606601717798212, 1.414213562373095}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"White \"", "8"},
       "RowDefault"], 
      Offset[{2, 2}, {1.1034201137898196, 1.4569735043830936}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.8890872965260113, 1.414213562373095}, 0.04275994200999855], 
     InsetBox[
      RowBox[{"-", "3"}], 
      Offset[{2, 2}, {3.93184723853601, 1.4569735043830936}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.35355339059327373, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"Black \"", "20"},
       "RowDefault"], Offset[{2, 2}, {0.3963133326032723, 0.749866723196546}],
       ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.7677669529663687, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox["8", Offset[{2, 2}, {1.810526894976367, 0.749866723196546}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.181980515339464, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox["12", Offset[{2, 2}, {3.2247404573494625, 0.749866723196546}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.596194077712559, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      RowBox[{"-", "3"}], 
      Offset[{2, 2}, {4.638954019722557, 0.749866723196546}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {DiskBox[{0., 0.}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"White \"", "20"},
       "RowDefault"], 
      Offset[{2, 2}, {0.04275994200999855, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.7071067811865475, 0.}, 0.04275994200999855], 
     InsetBox["2", Offset[{2, 2}, {0.749866723196546, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.414213562373095, 0.}, 0.04275994200999855], 
     InsetBox["6", Offset[{2, 2}, {1.4569735043830936, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.1213203435596424, 0.}, 0.04275994200999855], 
     InsetBox["8", Offset[{2, 2}, {2.164080285569641, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{2.82842712474619, 0.}, 0.04275994200999855], 
     InsetBox["12", Offset[{2, 2}, {2.8711870667561885, 0.04275994200999855}],
       ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.5355339059327373, 0.}, 0.04275994200999855], 
     InsetBox["7", Offset[{2, 2}, {3.578293847942736, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.242640687119285, 0.}, 0.04275994200999855], InsetBox[
      RowBox[{"-", "10"}], 
      Offset[{2, 2}, {4.285400629129283, 0.04275994200999855}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{4.949747468305833, 0.}, 0.04275994200999855], InsetBox[
      RowBox[{"-", "3"}], 
      Offset[{2, 2}, {4.992507410315831, 0.04275994200999855}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}}},
  FormatType->TraditionalForm,
  FrameTicks->None,
  ImageSize->400]], "Output",
 CellChangeTimes->{{3.831595821320999*^9, 3.8315958693548527`*^9}, 
   3.83159720351062*^9},
 CellLabel->"Out[69]=",ExpressionUUID->"6c848181-49ac-4150-b6ec-f9234875a73f"]
}, {2}]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Alpha Beta Pruning", "Subsection",
 CellChangeTimes->{{3.831593631706276*^9, 3.831593636052731*^9}, {
  3.831596300856468*^9, 3.831596314106708*^9}},
 TextAlignment->Center,ExpressionUUID->"9f42e75b-0077-42c6-9953-2ca442cd0bea"],

Cell["\<\
As in minimax, Black gets a 6 in the lower left. Moving to the right from \
black with the 6 and going down on the left. White gets a 7 at least so no \
point in examining the score to its right. Black chooses the move that give \
it 6, so White gets a 6 for that branch. Moving to the right, White will \
choose the move that gives a 2 so black\[CloseCurlyQuote]s score is 2. Black \
wants to minimize, so moving to the right could only be less than or equal to \
2 and White\[CloseCurlyQuote]s other move gives it a 6, so the rest of this \
branch does not need to be considered and White has a 6 for this position.\
\>", "Text",
 CellChangeTimes->{{3.831675317334292*^9, 3.8316753907175817`*^9}, {
  3.8316759264213448`*^9, 3.8316759695779333`*^9}, {3.831676009939179*^9, 
  3.831676016085444*^9}, {3.8316760638860703`*^9, 3.83167622830626*^9}, {
  3.831676279392894*^9, 
  3.831676424804264*^9}},ExpressionUUID->"01f9cf52-501c-4c14-819c-\
71e39a2fb22b"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TreePlot", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"1", "\[Rule]", "2"}], ",", 
     RowBox[{"3", "\[Rule]", "1"}], ",", 
     RowBox[{"2", "\[Rule]", "4"}], ",", 
     RowBox[{"2", "\[Rule]", "5"}], ",", 
     RowBox[{"3", "->", "6"}], ",", 
     RowBox[{"3", "->", "7"}], ",", 
     RowBox[{"4", "->", "8"}], ",", 
     RowBox[{"4", "->", "9"}], ",", 
     RowBox[{"5", "->", "10"}], ",", 
     RowBox[{"5", "->", "11"}], ",", 
     RowBox[{"6", "->", "12"}], ",", 
     RowBox[{"6", "->", "13"}], ",", 
     RowBox[{"7", "->", "14"}], ",", 
     RowBox[{"7", "->", "15"}]}], "}"}], ",", 
   RowBox[{"VertexLabels", "\[Rule]", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"1", "->", "6"}], ",", 
      RowBox[{"2", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "6"}], "}"}], "]"}]}], ",", 
      RowBox[{"4", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<Black \>\"", ",", "6"}], "}"}], "]"}]}], ",", 
      RowBox[{"6", "->", "2"}], ",", 
      RowBox[{"8", "->", 
       RowBox[{"Row", "[", 
        RowBox[{"{", 
         RowBox[{"\"\<White \>\"", ",", "4"}], "}"}], "]"}]}], ",", 
      RowBox[{"9", "->", "6"}], ",", 
      RowBox[{"10", "->", "7"}], ",", 
      RowBox[{"12", "->", "1"}], ",", 
      RowBox[{"13", "->", "2"}]}], "}"}]}], ",", 
   RowBox[{"ImageSize", "->", "400"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.831590675206427*^9, 3.831590693737986*^9}, {
   3.831590869610656*^9, 3.831591114113171*^9}, {3.831595768370138*^9, 
   3.8315958040157967`*^9}, {3.8315958456012487`*^9, 3.831595868140648*^9}, {
   3.831596923347599*^9, 3.831596964982407*^9}, {3.831597033838833*^9, 
   3.83159709219065*^9}, {3.831597409104373*^9, 3.831597485349126*^9}, {
   3.83159752005204*^9, 3.8315975660723267`*^9}, {3.831597651865744*^9, 
   3.831597709907063*^9}, 3.831676057438446*^9},
 CellLabel->"In[1]:=",
 CellID->213611487,ExpressionUUID->"9ccfef1d-93dd-402a-b532-6ab4bc59d856"],

Cell[BoxData[
 GraphicsBox[{
   {Hue[0.6, 0.7, 0.5], Opacity[0.7], Arrowheads[0.], ArrowBox[CompressedData["
1:eJxTTMoPSmVmYGDgA2ImKA4OWT+z6wyzw82c+2fKfjBA6Q/2Z6zr0+Yt+GaP
Lm/56d2ZmzL8DjB5dPUQ+hqUfoYhv59LnuGYxx+4PLp5bsr+xptKOB1wyU9L
cN/ckCQEl0e3jwENoMujq0N3D8weXPKwcIDJo7sXQrPhlIeYxwOXR/cPxHwB
nPKQ+BCGywMAvrS/KQ==
     "], 0.04275994200999855]}, 
   {Hue[0.6, 0.2, 0.8], EdgeForm[{GrayLevel[0], Opacity[
    0.7]}], {DiskBox[{2.4748737341529163, 2.1213203435596424}, 
      0.04275994200999855], 
     InsetBox["6", Offset[{2, 2}, {2.517633676162915, 2.164080285569641}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.0606601717798212, 1.414213562373095}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"White \"", "6"},
       "RowDefault"], 
      Offset[{2, 2}, {1.1034201137898196, 1.4569735043830936}], ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, 
    DiskBox[{3.8890872965260113, 1.414213562373095}, 0.04275994200999855], {
     DiskBox[{0.35355339059327373, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox[
      TemplateBox[{"\"Black \"", "6"},
       "RowDefault"], Offset[{2, 2}, {0.3963133326032723, 0.749866723196546}],
       ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, 
    DiskBox[{1.7677669529663687, 0.7071067811865475}, 0.04275994200999855], {
     DiskBox[{3.181980515339464, 0.7071067811865475}, 0.04275994200999855], 
     InsetBox["2", Offset[{2, 2}, {3.2247404573494625, 0.749866723196546}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, 
    DiskBox[{4.596194077712559, 0.7071067811865475}, 0.04275994200999855], {
     DiskBox[{0., 0.}, 0.04275994200999855], InsetBox[
      TemplateBox[{"\"White \"", "4"},
       "RowDefault"], 
      Offset[{2, 2}, {0.04275994200999855, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{0.7071067811865475, 0.}, 0.04275994200999855], 
     InsetBox["6", Offset[{2, 2}, {0.749866723196546, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{1.414213562373095, 0.}, 0.04275994200999855], 
     InsetBox["7", Offset[{2, 2}, {1.4569735043830936, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, 
    DiskBox[{2.1213203435596424, 0.}, 0.04275994200999855], {
     DiskBox[{2.82842712474619, 0.}, 0.04275994200999855], 
     InsetBox["1", Offset[{2, 2}, {2.8711870667561885, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, {
     DiskBox[{3.5355339059327373, 0.}, 0.04275994200999855], 
     InsetBox["2", Offset[{2, 2}, {3.578293847942736, 0.04275994200999855}], 
      ImageScaled[{0, 0}],
      BaseStyle->"Graphics"]}, 
    DiskBox[{4.242640687119285, 0.}, 0.04275994200999855], 
    DiskBox[{4.949747468305833, 0.}, 0.04275994200999855]}},
  FormatType->TraditionalForm,
  FrameTicks->None,
  ImageSize->400]], "Output",
 CellChangeTimes->{{3.8315973871436357`*^9, 3.8315974861763363`*^9}, {
   3.831597523353834*^9, 3.831597567035707*^9}, {3.831597674058482*^9, 
   3.831597710793045*^9}, 3.8316760583169203`*^9},
 CellLabel->"Out[1]=",ExpressionUUID->"4d660d3f-e5ce-46a9-8ac6-27d84a5b2341"]
}, {2}]]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["AlphaBeta Function Video 59", "Section",
 CellChangeTimes->{{3.8626860280468884`*^9, 
  3.8626860461847973`*^9}},ExpressionUUID->"656a5818-18c1-4fe6-b3e3-\
4b1c773def78"],

Cell["\<\
static int AlphaBeta(int alpha, int beta, int depth, S_BOARD *pos, \
S_SEARCHINFO *info, int DoNull) {

\tif(depth == 0) {
\t\tinfo->nodes++;
\t\treturn EvalPosition(pos);
\t}
\t
\t// A node has been visited so increment nodes.
\tinfo->nodes++;
\t
\tif(IsRepetition(pos) || pos->fiftyMove >= 100) {
\t\t//position is a draw
\t\treturn 0;
\t}
\t
\tif(pos->ply > MAXDEPTH - 1) {
\t\t//depth is the maximum allowed, principal variation array only holds \
MAXDEPTH moves
\t\treturn EvalPosition(pos);
\t}
\t
\tS_MOVELIST list[1];
          GenerateAllMoves(pos,list);
      
          int MoveNum = 0;
\tint Legal = 0; // once gone through all the moves, if none legal, the \
position is either checkmate or stalemate
\tint OldAlpha = alpha;// once gone through the moves, if alpha no longer \
equal to OldAlpha, store the best move found in the principal variation
\t// a move has been found which beat alpha
\tint BestMove = NOMOVE;
\tint Score = -INFINITE;
\t
\t//very similar to perft
\tfor(MoveNum = 0; MoveNum < list->count; ++MoveNum) {\t
       
                   if ( !MakeMove(pos,list->moves[MoveNum].move))  {
                        continue;
                    }
        
                    Legal++;
                    //use negamax
                    Score = -AlphaBeta( -beta, -alpha, depth-1, pos, info, \
TRUE);\t\t
                    TakeMove(pos);
\t\t
\t\tif(Score > alpha) {
\t\t\t//improve alpha
\t\t\tif(Score >= beta) {
\t\t\t          //have a beta cutoff
\t\t\t\treturn beta;
\t\t\t}
\t\t\talpha = Score;
\t\t\tBestMove = list->moves[MoveNum].move;
\t\t}\t\t
           }
\t
\tif(Legal == 0) {
\t\tif(SqAttacked(pos->KingSq[pos->side],pos->side^1,pos)) {
\t\t           //no legal moves and in check - it is checkmate
\t\t\t//return distance to mate from the root
\t\t\treturn -MATE + pos->ply;
\t\t} else {
\t\t\t//stalemate
\t\t\treturn 0;
\t\t}
\t}
\t
\tif(alpha != OldAlpha) {
\t           //alpha has been improved so store the best move for this \
position which will then end up in the pv array
\t\tStorePvMove(pos, BestMove);
\t}
\t
\t//if alpha was not improved, just return it
\treturn alpha;
} \
\>", "Text",
 CellChangeTimes->{{3.862686050257311*^9, 3.862686097761894*^9}, {
  3.862686237194396*^9, 3.862686273772007*^9}, {3.862686359131667*^9, 
  3.862686369697003*^9}, {3.862686416084725*^9, 3.862686491078044*^9}, {
  3.86268656292766*^9, 3.8626866203617764`*^9}, {3.862686774048541*^9, 
  3.862686893868539*^9}, {3.862686944533091*^9, 3.862686979037175*^9}, {
  3.8626870531319923`*^9, 3.86268705398661*^9}, {3.8626871234787693`*^9, 
  3.862687136574821*^9}, {3.862687193635933*^9, 3.862687201767189*^9}, {
  3.862687243585701*^9, 3.8626872898250237`*^9}, {3.862687351405384*^9, 
  3.8626874302856617`*^9}, {3.862687500959711*^9, 3.8626875974325333`*^9}, {
  3.862687628059119*^9, 
  3.862687712597731*^9}},ExpressionUUID->"bd9a8585-2d95-4d7a-b3ef-\
c5cf0a74694c"]
}, Open  ]],

Cell[CellGroupData[{

Cell["AlphaBeta Function", "Section",
 CellChangeTimes->{{3.860254105492196*^9, 3.8602541214669447`*^9}, {
  3.860274876607132*^9, 3.8602748984576807`*^9}, {3.8602757032574577`*^9, 
  3.8602757054500227`*^9}},ExpressionUUID->"2c6937d6-41ed-4f4a-acaa-\
0de0c86f8e53"],

Cell["\<\
#define infinite 30000
#define ISMATE (infinite - MAXDEPTH)\
\>", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, 
   3.860253657424129*^9, 
   3.860253701364787*^9},ExpressionUUID->"29cd0348-d809-4bef-aaa1-\
f67db9f569ef"],

Cell["int rootDepth;", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, 
   3.860253657424129*^9, 3.8602537026221437`*^9, 
   3.860254039533012*^9},ExpressionUUID->"46adc27c-6e2f-458e-9514-\
bdec25771b00"],

Cell["\<\
static void CheckUp(S_SEARCHINFO* info) {
    // .. check if time up, or interrupt from GUI
    if (info->timeset == TRUE && GetTimeMs() > info->stoptime) {
        info->stopped = TRUE;
    }

    ReadInput(info);
}\
\>", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, 
   3.860253657424129*^9, 3.860253707399069*^9, 
   3.8602540430448847`*^9},ExpressionUUID->"83c365d6-5951-497e-94c7-\
81a872a46590"],

Cell["\<\
static int AlphaBeta(int alpha, int beta, int depth, S_BOARD* pos, \
S_SEARCHINFO* info) {

    if (depth == 0) {
        return Quiescence(alpha, beta, pos, info);
    }

    if ((info->nodes & 2047) == 0) {
        CheckUp(info);
    }

    info->nodes++;

    if ((IsRepetition(pos) || pos->fiftyMove >= 100) && pos->ply) {
        return 0;
    }

    if (pos->ply > MAXDEPTH - 1) {
        return EvalPosition(pos);
    }

    int InCheck = SqAttacked(pos->KingSq[pos->side], pos->side ^ 1, pos);

    if (InCheck == TRUE) {
        depth++;
    }

    int Score = -infinite;

    S_MOVELIST list[1];
    GenerateAllMoves(pos, list);

    int MoveNum = 0;
    int Legal = 0;
    int OldAlpha = alpha;
    int BestMove = NOMOVE;
    int PvMove = ProbePvTable(pos);
    Score = -infinite;

    if (PvMove != NOMOVE) {
        for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {
            if (list->moves[MoveNum].move == PvMove) {
                list->moves[MoveNum].score = 2000000;
                break;
            }
        }
    }

    for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {

        PickNextMove(MoveNum, list);

        //if move is illegal, go to next one
        if (!MakeMove(pos, list->moves[MoveNum].move)) {
            continue;
        }

        //if move is legal
        Legal++;
        Score = -AlphaBeta(-beta, -alpha, depth - 1, pos, info);
        TakeMove(pos);

        if (info->stopped == TRUE) {
            return 0;
        }

        if (Score > alpha) {
            if (Score >= beta) {
                if (Legal == 1) {
                    info->fhf++;
                }
                info->fh++;

                if (!(list->moves[MoveNum].move & MFLAGCAP)) {
                    pos->searchKillers[1][pos->ply] = \
pos->searchKillers[0][pos->ply];
                    pos->searchKillers[0][pos->ply] = \
list->moves[MoveNum].move;
                }

                return beta;
            }
            alpha = Score;
            BestMove = list->moves[MoveNum].move;
            if (!(list->moves[MoveNum].move & MFLAGCAP)) {
                pos->searchHistory[pos->pieces[FROMSQ(BestMove)]][TOSQ(\
BestMove)] += depth;
            }
        }
    }

    if (Legal == 0) {
        if (InCheck) {
            return -infinite + pos->ply;
        }
        else {
            return 0;
        }
    }

    if (alpha != OldAlpha) {
        StorePvMove(pos, BestMove);
    }

    return alpha;
}\
\>", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, {
   3.8602537186620417`*^9, 
   3.86025372869407*^9}},ExpressionUUID->"4ef751d8-9027-42db-8068-\
919f7ae1052a"]
}, Open  ]],

Cell["Move Ordering - Killer, History Heuristics, PV Move", "Section",
 CellChangeTimes->{{3.860254254736775*^9, 
  3.860254260100831*^9}},ExpressionUUID->"1abb9ea8-eb07-47ee-9395-\
3ab06cb919f9"],

Cell[CellGroupData[{

Cell["Quiescence - Getting rid of the horizon effect", "Section",
 CellChangeTimes->{{3.860254279177621*^9, 
  3.8602542827079763`*^9}},ExpressionUUID->"fc910055-988b-4279-ac21-\
f419bf32032b"],

Cell["\<\
static int Quiescence(int alpha, int beta, S_BOARD* pos, S_SEARCHINFO* info) {

    if ((info->nodes & 2047) == 0) {
        CheckUp(info);
    }

    info->nodes++;

    if (IsRepetition(pos) || pos->fiftyMove >= 100) {
        return 0;
    }

    if (pos->ply > MAXDEPTH - 1) {
        return EvalPosition(pos);
    }

    int Score = EvalPosition(pos);

    if (Score >= beta) {
        return beta;
    }

    if (Score > alpha) {
        alpha = Score;
    }

    S_MOVELIST list[1];
    GenerateAllCaps(pos, list);

    int MoveNum = 0;
    int Legal = 0;
    int OldAlpha = alpha;
    int BestMove = NOMOVE;
    Score = -infinite;
    int PvMove = ProbePvTable(pos);

    if (PvMove != NOMOVE) {
        for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {
            if (list->moves[MoveNum].move == PvMove) {
                list->moves[MoveNum].score = 2000000;
                break;
            }
        }
    }

    for (MoveNum = 0; MoveNum < list->count; ++MoveNum) {

        PickNextMove(MoveNum, list);

        if (!MakeMove(pos, list->moves[MoveNum].move)) {
            continue;
        }

        Legal++;
        Score = -Quiescence(-beta, -alpha, pos, info);
        TakeMove(pos);

        if (info->stopped == TRUE) {
            return 0;
        }

        if (Score > alpha) {
            if (Score >= beta) {
                if (Legal == 1) {
                    info->fhf++;
                }
                info->fh++;
                return beta;
            }
            alpha = Score;
            BestMove = list->moves[MoveNum].move;
        }
    }

    if (alpha != OldAlpha) {
        StorePvMove(pos, BestMove);
    }

    return alpha;
}\
\>", "Text",
 CellChangeTimes->{
  3.859761991407433*^9, {3.8598271008744*^9, 3.8598271020912*^9}, 
   3.860253715680316*^9, 
   3.860253772584961*^9},ExpressionUUID->"03024f77-c94a-4c55-b00c-\
88b4c3917539"]
}, Closed]],

Cell[CellGroupData[{

Cell["UCI Protocol", "Section",
 CellChangeTimes->{{3.860254452352613*^9, 
  3.8602544630574636`*^9}},ExpressionUUID->"bbcce15d-519b-491c-b250-\
0c917b67b3ab"],

Cell["Detailed here", "Text",
 CellChangeTimes->{{3.860254770477131*^9, 3.8602547730921507`*^9}, {
  3.860256499790473*^9, 
  3.860256506826803*^9}},ExpressionUUID->"8f0ab1ec-a568-457c-826c-\
c3f4cb705b7b"],

Cell["https://www.stmintz.com/ccc/index.php?id=141612", "Text",
 CellChangeTimes->{{3.860254770477131*^9, 3.8602547730921507`*^9}, {
  3.860256499790473*^9, 
  3.860256511945798*^9}},ExpressionUUID->"478882c1-3e83-4c95-93bf-\
f7edcb3296bb"]
}, Closed]],

Cell[CellGroupData[{

Cell["UCI Implementation in the Engine", "Section",
 CellChangeTimes->{{3.8597620616607027`*^9, 3.85976206352887*^9}, {
  3.860256565244417*^9, 
  3.8602565853705072`*^9}},ExpressionUUID->"fe0b68d3-690e-4e1d-ac33-\
75ca31034866"],

Cell["\<\
#define INPUTBUFFER 400 * 6

// go depth 6 wtime 180000 btime 100000 binc 1000 winc 1000 movetime 1000 \
movestogo 40
void ParseGo(char* line, S_SEARCHINFO* info, S_BOARD* pos) {

    int depth = -1, movestogo = 30, movetime = -1;
    int time = -1, inc = 0;
    char* ptr = NULL;
    info->timeset = FALSE;

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]infinite\
\[CloseCurlyDoubleQuote]))) {
        ;
    }

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]binc\
\[CloseCurlyDoubleQuote])) && pos->side == BLACK) {
        inc = atoi(ptr + 5);
    }

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]winc\
\[CloseCurlyDoubleQuote])) && pos->side == WHITE) {
        inc = atoi(ptr + 5);
    }

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]wtime\
\[CloseCurlyDoubleQuote])) && pos->side == WHITE) {
        time = atoi(ptr + 6);
    }

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]btime\
\[CloseCurlyDoubleQuote])) && pos->side == BLACK) {
        time = atoi(ptr + 6);
    }

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]movestogo\
\[CloseCurlyDoubleQuote]))) {
        movestogo = atoi(ptr + 10);
    }

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]movetime\
\[CloseCurlyDoubleQuote]))) {
        movetime = atoi(ptr + 9);
    }

    if ((ptr = strstr(line, \[OpenCurlyDoubleQuote]depth\
\[CloseCurlyDoubleQuote]))) {
        depth = atoi(ptr + 6);
    }

    if (movetime != -1) {
        time = movetime;
        movestogo = 1;
    }

    info->starttime = GetTimeMs();
    info->depth = depth;

    if (time != -1) {
        info->timeset = TRUE;
        time /= movestogo;
        time -= 50;
        info->stoptime = info->starttime + time + inc;
    }

    if (depth == -1) {
        info->depth = MAXDEPTH;
    }

    printf(\[OpenCurlyDoubleQuote]time:%d start:%d stop:%d depth:%d \
timeset:%d\\n\[CloseCurlyDoubleQuote],
        time, info->starttime, info->stoptime, info->depth, info->timeset);
    SearchPosition(pos, info);
}

void ParsePosition(char* lineIn, S_BOARD* pos) {

    lineIn += 9;
    char* ptrChar = lineIn;

    if (strncmp(lineIn, \[OpenCurlyDoubleQuote]startpos\
\[CloseCurlyDoubleQuote], 8) == 0) {
        ParseFen(START_FEN, pos);
    }
    else {
        ptrChar = strstr(lineIn, \[OpenCurlyDoubleQuote]fen\
\[CloseCurlyDoubleQuote]);
        if (ptrChar == NULL) {
            ParseFen(START_FEN, pos);
        }
        else {
            ptrChar += 4;
            ParseFen(ptrChar, pos);
        }
    }

    ptrChar = strstr(lineIn, \[OpenCurlyDoubleQuote]moves\
\[CloseCurlyDoubleQuote]);
    int move;

    if (ptrChar != NULL) {
        ptrChar += 6;
        while (*ptrChar) {
            move = ParseMove(ptrChar, pos);
            if (move == NOMOVE) break;
            MakeMove(pos, move);
            pos->ply = 0;
            while (*ptrChar && *ptrChar != \[OpenCurlyQuote] \
\[OpenCurlyQuote]) ptrChar++;
            ptrChar++;
        }
    }
    PrintBoard(pos);
}

void Uci_Loop(S_BOARD* pos, S_SEARCHINFO* info) {

    setbuf(stdin, NULL);
    setbuf(stdout, NULL);

    char line[INPUTBUFFER];
    printf(\[OpenCurlyDoubleQuote]id name %s\\n\[CloseCurlyDoubleQuote], NAME);
    printf(\[OpenCurlyDoubleQuote]id author Jay Warendorff\\n\
\[CloseCurlyDoubleQuote]);
    printf(\[OpenCurlyDoubleQuote]uciok\\n\[CloseCurlyDoubleQuote]);

    while (TRUE) {
        memset(&line[0], 0, sizeof(line));
        fflush(stdout);
        if (!fgets(line, INPUTBUFFER, stdin))
            continue;

        if (line[0] == \[OpenCurlyQuote]\\n\[CloseCurlyQuote])
            continue;

        if (!strncmp(line, \[OpenCurlyDoubleQuote]isready\
\[CloseCurlyDoubleQuote], 7)) {
            printf(\[OpenCurlyDoubleQuote]readyok\\n\[CloseCurlyDoubleQuote]);\

            continue;
        }
        else if (!strncmp(line, \[OpenCurlyDoubleQuote]position\
\[CloseCurlyDoubleQuote], 8)) {
            ParsePosition(line, pos);
        }
        else if (!strncmp(line, \[OpenCurlyDoubleQuote]ucinewgame\
\[CloseCurlyDoubleQuote], 10)) {
            ParsePosition(\[OpenCurlyDoubleQuote]position startpos\\n\
\[CloseCurlyDoubleQuote], pos);
        }
        else if (!strncmp(line, \[OpenCurlyDoubleQuote]go\
\[CloseCurlyDoubleQuote], 2)) {
            ParseGo(line, info, pos);
        }
        else if (!strncmp(line, \[OpenCurlyDoubleQuote]quit\
\[CloseCurlyDoubleQuote], 4)) {
            info->quit = TRUE;
            break;
        }
        else if (!strncmp(line, \[OpenCurlyDoubleQuote]uci\
\[CloseCurlyDoubleQuote], 3)) {
            printf(\[OpenCurlyDoubleQuote]id name %s\\n\
\[CloseCurlyDoubleQuote], NAME);
            printf(\[OpenCurlyDoubleQuote]id author Jay Warendorff\\n\
\[CloseCurlyDoubleQuote]);
            printf(\[OpenCurlyDoubleQuote]uciok\\n\[CloseCurlyDoubleQuote]);
        }
        if (info->quit) break;
    }
}\
\>", "Text",
 CellChangeTimes->{
  3.85976204760185*^9},ExpressionUUID->"26548146-8a45-4892-8884-dc19a4d349bf"]
}, Closed]],

Cell[CellGroupData[{

Cell["Connect GUI", "Section",
 CellChangeTimes->{3.859761577037689*^9, 
  3.859826506087117*^9},ExpressionUUID->"9b47d032-c2a5-4f04-b1bf-\
0ff6784d14c1"],

Cell["\<\
int InputWaiting()
{
    static int init = 0, pipe;
    static HANDLE inh;
    DWORD dw;

    if (!init) {
        init = 1;
        inh = GetStdHandle(STD_INPUT_HANDLE);
        pipe = !GetConsoleMode(inh, &dw);
        if (!pipe) {
            SetConsoleMode(inh, dw & ~(ENABLE_MOUSE_INPUT | \
ENABLE_WINDOW_INPUT));
            FlushConsoleInputBuffer(inh);
        }
    }
    if (pipe) {
        if (!PeekNamedPipe(inh, NULL, 0, NULL, &dw, NULL)) return 1;
        return dw;
    }
    else {
        GetNumberOfConsoleInputEvents(inh, &dw);
        return dw <= 1 ? 0 : dw;
    }
}

void ReadInput(S_SEARCHINFO* info) {
    int             bytes;
    char            input[256] = \[OpenCurlyDoubleQuote]\
\[CloseCurlyDoubleQuote], * endc;

    if (InputWaiting()) {
        info->stopped = TRUE;
        do {
            bytes = read(fileno(stdin), input, 256);
        } while (bytes < 0);
        endc = strchr(input, \[OpenCurlyQuote]\\n\[CloseCurlyQuote]);
        if (endc) *endc = 0;

        if (strlen(input) > 0) {
            if (!strncmp(input, \[OpenCurlyDoubleQuote]quit\
\[CloseCurlyDoubleQuote], 4)) {
                info->quit = TRUE;
            }
        }
        return;
    }
}\
\>", "Text",
 CellChangeTimes->{3.859761934024848*^9, 
  3.860255042205529*^9},ExpressionUUID->"c711b281-cb7b-4b22-a534-\
98100673b87d"]
}, Closed]],

Cell[CellGroupData[{

Cell["Main", "Section",
 CellChangeTimes->{{3.859762072096933*^9, 
  3.859762073390306*^9}},ExpressionUUID->"bed50d65-7655-4b16-9524-\
62c9610da330"],

Cell["\<\
int main() {

    // debug mode variable
    int debug = 0;

    // if debugging - debug 1
    if (debug)
    {
        AllInit();

        S_BOARD pos[1];
        S_SEARCHINFO info[1];
        info->quit = FALSE;
        pos->PvTable->pTable = NULL;
        InitPvTable(pos->PvTable);

        //Perft results depth 3 - 8902, depth 4 - 197,281, depth 5 - \
4,865,609, depth 6 - 119,060,324

        ParseFen(START_FEN, pos);
        PerftTest(6, pos);
        while (1);
    }
    else
    {
        AllInit();

        S_BOARD pos[1];
        S_SEARCHINFO info[1];
        info->quit = FALSE;
        pos->PvTable->pTable = NULL;
        InitPvTable(pos->PvTable);
        setbuf(stdin, NULL);
        setbuf(stdout, NULL);

        char line[256];
        while (TRUE) {
            memset(&line[0], 0, sizeof(line));

            fflush(stdout);
            if (!fgets(line, 256, stdin))
                continue;
            if (line[0] == \[OpenCurlyQuote]\\n\[CloseCurlyQuote])
                continue;
            if (!strncmp(line, \[OpenCurlyDoubleQuote]uci\
\[CloseCurlyDoubleQuote], 3)) {
                Uci_Loop(pos, info);
                if (info->quit == TRUE) break;
                continue;
            }
            else if (!strncmp(line, \[OpenCurlyDoubleQuote]quit\
\[CloseCurlyDoubleQuote], 4)) {
                break;
            }
        }

        free(pos->PvTable->pTable);
    }
    return 0;
}\
\>", "Text",
 CellChangeTimes->{
  3.859762089522409*^9, {3.860241600550273*^9, 
   3.86024163191249*^9}},ExpressionUUID->"9f241d94-3c96-4f02-9f0b-\
2c8a55ce7848"]
}, Closed]],

Cell[CellGroupData[{

Cell["Further Development", "Section",
 CellChangeTimes->{{3.8602745249616833`*^9, 
  3.860274535569371*^9}},ExpressionUUID->"4916af9e-3078-4fc0-92dd-\
e4e804e1584a"],

Cell[CellGroupData[{

Cell["Pseudo-legal Move Generator", "Subsection",
 CellChangeTimes->{{3.8602745958764668`*^9, 3.860274599547439*^9}, {
  3.860274709413404*^9, 
  3.860274712513229*^9}},ExpressionUUID->"8595eb4b-78f4-4e9e-847f-\
e1cb4e942e4b"],

Cell["\<\
Use a pseudo-legal move generator instead of a legal one. Once you implement \
a decent move ordering in your engine, the first several moves it looks at \
will hopefully be the best, and so it won\[CloseCurlyQuote]t waste time \
looking at all the other moves, and won\[CloseCurlyQuote]t spend the extra \
work of calculating if they\[CloseCurlyQuote]re legal. But with a fully legal \
move generator, the time is spent verifying every move is legal regardless of \
if you actually have to.\
\>", "Text",
 CellChangeTimes->{{3.837452436602313*^9, 3.837452456526812*^9}, {
  3.860274618927937*^9, 
  3.860274655443798*^9}},ExpressionUUID->"68336e0c-83e9-4334-835f-\
d5a9a9233eab"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Board Representation Using Bitboards", "Subsection",
 CellChangeTimes->{{3.860274683069713*^9, 3.8602747208779287`*^9}, {
  3.860275035704316*^9, 
  3.860275044202463*^9}},ExpressionUUID->"bac28685-2a29-45b4-9abd-\
a1c270c0251e"],

Cell["Easier to improve the evaluation function.", "Text",
 CellChangeTimes->{{3.860274726601012*^9, 
  3.860274755763669*^9}},ExpressionUUID->"944959ac-1f44-4832-8930-\
92298140a268"]
}, Open  ]],

Cell[CellGroupData[{

Cell["\<\
Staged Move Generation, Null Move Pruning, Transposition Table, Razoring, \
Futility Pruning, Late Move Reductions, Aspiration Window\
\>", "Subsection",
 CellChangeTimes->{{3.860274951489709*^9, 3.860275025237659*^9}, {
  3.860275928757422*^9, 3.860275932541902*^9}, {3.860431171658062*^9, 
  3.860431180779972*^9}},ExpressionUUID->"971bc7e4-7c6c-4c63-b7b5-\
def750e2774e"],

Cell["https://www.chessprogramming.org/Tapered_Eval", "Text",
 CellChangeTimes->{
  3.861039592013215*^9},ExpressionUUID->"5e6e6102-973f-4753-85d5-\
d8d850b312cc"],

Cell["\<\
From http://web.archive.org/web/20070826142534/http://www.seanet.com/~brucemo/\
topics/aspiration.htm\
\>", "Text",
 CellChangeTimes->{{3.8610347510781116`*^9, 
  3.861034754585149*^9}},ExpressionUUID->"2698d452-a16a-44ef-9e8d-\
65d571b4278f"],

Cell["\<\
An aspiration window is an enhancement to iterative deepening.  The simplest \
implementation of iterative deepening works as follows:

for (depth = 1;; depth++) {
val = AlphaBeta(depth, -INFINITY, INFINITY);
 if (TimedOut())
break;
}

Alpha-beta is called with a \[OpenCurlyDoubleQuote]window\
\[CloseCurlyDoubleQuote] of +/- INFINITY, presumably large positive and \
negative values.

It is possible to enhance this to a degree by making the assumption that the \
value of the search in the next iteration is not likely to be too much \
different from the value of the search in the iteration just completed.  Here\
\[CloseCurlyQuote]s the code:

#define valWINDOW  50

alpha = -INFINITY;
beta = INFINITY;
for (depth = 1;;) {
val = AlphaBeta(depth, alpha, beta);
if (TimedOut())
break;
if ((val <= alpha) || (val >= beta)) {
alpha = -INFINITY;    // We fell outside the window, so try again with a
beta = INFINITY;      //  full-width window (and the same depth).
continue;
}
alpha = val - valWINDOW;  // Set up the window for the next iteration.
beta = val + valWINDOW;
depth++;
}\
\>", "Text",
 CellChangeTimes->{{3.86043152348715*^9, 
  3.860431602314137*^9}},ExpressionUUID->"e7ff9d50-2a0c-4a4d-96f9-\
39b87ae1211e"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Pawn Hash Table", "Subsection",
 CellChangeTimes->{{3.8622652424684763`*^9, 
  3.862265249851284*^9}},ExpressionUUID->"46e3bddf-4551-44ac-a0fd-\
2a6cbbc413d7"],

Cell[CellGroupData[{

Cell["\<\
Alvin Peng 5/22/22 on Talk Chess - What pruning techniques should I add to my \
engine?\
\>", "Subsubsection",
 CellChangeTimes->{{3.862265284097838*^9, 3.8622653234631367`*^9}, {
  3.862265400601391*^9, 
  3.862265402026514*^9}},ExpressionUUID->"172ebfae-91d7-4d11-90e1-\
86666024a8f4"],

Cell["\<\
Instead of reevaluating pawn structure every time you call your evaluation \
function, you can evaluate it once and save that evaluation in a dedicated \
hash table. Pawn structure isn\[CloseCurlyQuote]t very dynamic, so pawn \
tables have very high hit rates. You index the pawn hash table with a pawn \
key, which is like the zobrist hash key but only for pawns.

Material hash tables store information regarding piece counts. You could use \
it to store things like game phase or material imbalance. Lots of chess \
engines keep an incrementally updated material key, which updates whenever \
there is a capture or promotion. This key is used to index the material hash \
table, as well as check for drawn material.

In terms of resources, you could take a look at implementations in other \
chess engines. Many of them will have a \[OpenCurlyDoubleQuote]pawnKey\
\[CloseCurlyDoubleQuote] or \[OpenCurlyDoubleQuote]materialKey\
\[CloseCurlyDoubleQuote] member in their board structures.\
\>", "Text",
 CellChangeTimes->{
  3.862265301675313*^9},ExpressionUUID->"4691ebc9-7595-47e1-9c34-\
bd7acabf26f7"]
}, Open  ]],

Cell[CellGroupData[{

Cell["\<\
H. G. Muller 5/22/22 on Talk Chess - What pruning techniques should I add to \
my engine?\
\>", "Subsubsection",
 CellChangeTimes->{{3.8622653395919867`*^9, 3.862265348511694*^9}, {
  3.862265384612989*^9, 
  3.8622654101569157`*^9}},ExpressionUUID->"bf082fb3-b3b1-4d98-82de-\
0512ee4a2867"],

Cell["\<\
The idea behind these hash tables is similar to that of the Transposition \
Table: you map the features for which you want to tabulate something onto a \
number through Zobrist hashing to get a hash key. For the TT you want the key \
to be dependent on all pieces and their location, plus a number of other \
infos (side to move, castling and e.p. rights). So you give every (color, \
pieceType, square) combination a different random number as base key, and XOR \
all of those. Since in general only one of the pieces moves, this is easy to \
update incrementally.

The Pawn key should only identify the Pawn structure, so you only need to \
have a key for every Pawn (and possibly the e.p. rights). You could calculate \
it exactly the same as the TT hash key, by setting the base keys for all \
non-Pawns to 0. For the material key you are only interested in what pieces \
are on the board, not where these are. So you only need a base key for every \
(color, pieceType) combination. You would only have to update it for moves \
that change material, i.e. for the captured piece, and for promotions.

The hashing scheme is always the same: part of the key you use to derive an \
\[OpenCurlyQuote]index\[CloseCurlyQuote] to a table, which tells where in the \
table the information for this position / pawn structure / material \
combination is stored. In that place you store the remaining part of the key \
as \[OpenCurlyQuote]signature\[CloseCurlyQuote], so you can test if the other \
data that is stored there indeed corresponds to the case you were looking \
for. If that signature matches your key, you use the information. If it doesn\
\[CloseCurlyQuote]t, you have to calculate the information you were hoping to \
find from scratch for the current position, and you store it in the table \
(together with the signature for the current position). And then use it.

The idea is that most of the time (say 95% or 99% of the cases) you would \
have a matching signature, and can use the information without calculating \
anything. Then you would only have to do an actual calculation in 5% or 1% of \
the cases, effectively speeding up the calculation by a factor 20 or 100. \
Then you don\[CloseCurlyQuote]t care too much whether the calculation was \
time-consuming.

The tables could store all kinds of data in addition to the signature. E.g. \
for a Pawn table you could have the total score (e.g. white POV) for all \
passers, doubled Pawns, isolated Pawns etc. You could also store information \
that helps speeding up other evaluation terms that do not purely depend on \
Pawns. E.g. you could store the number of Pawns of either color on light and \
dark squares, to know whether you have a good or a bad Bishop. Or you could \
list half-open files for white and black (e.g. as a byte where each bit \
represents a file), to give a bonus for Rooks being on these files. You could \
store the location and promotion square of the most advanced passer, to \
quickly calculate in a Pawn ending whether a player has an unstoppable \
passer. You could calculate the quality of the King-side and Queen-side Pawn \
shield that a King would have when it had castled in that direction, for use \
if the King is indeed on the c- or g-file, or determining the value of \
castling rights if it can still castle.

In the material table you could store score corrections on the PST + material \
score for combinations of pieces. Such as the Bishop pair. Or factors with \
which the normal evaluation score should be multiplied for white and black \
(whichever naively seems to be ahead), to indicate drawishness. (E.g. for KBK \
you would want to multiply with 0, so that the naive +3 score is annihilated, \
and for KBPKN you would like a multiplier close to zero, to express that the \
Pawn will likely be lost through a Knight sacrifice.) Or you could indicate \
that a special evaluation routine should be called, and which one. (E.g. for \
KPK, which would determine whether it is a win and a draw depending on the \
actual K and P locations.)\
\>", "Text",
 CellChangeTimes->{
  3.862265373202943*^9},ExpressionUUID->"09a00537-4bb6-4e35-8526-\
b1739895ee71"]
}, Open  ]]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Fix for Null Move Pruning", "Section",
 CellChangeTimes->{{3.8603320836674757`*^9, 3.8603320850880947`*^9}, {
  3.860332432414551*^9, 
  3.86033244144773*^9}},ExpressionUUID->"8180b180-3534-4762-91ff-\
7b4051a399e7"],

Cell["\<\
If you followed VICE exactly you\[CloseCurlyQuote]ll have the condition that \
the side to move has to have a \[OpenCurlyDoubleQuote]big piece\
\[CloseCurlyDoubleQuote] aka non-pawn, non-king to perform a null move, \
however VICE mistakenly counts the king as a big piece meaning it will always \
allow null moves. Fixing this, not counting the king, in my engine (also \
based on VICE) allowed it to solve a lot of zugzwang positions it previously \
could not. \
\>", "Text",
 CellChangeTimes->{
  3.860332089387746*^9},ExpressionUUID->"d6c7f6c4-916d-48e3-b20f-\
b90f0b0e9711"]
}, Closed]],

Cell[CellGroupData[{

Cell["References", "Section",
 CellChangeTimes->{{3.860432176696849*^9, 
  3.860432180865737*^9}},ExpressionUUID->"e5dd233d-d827-4789-bf8c-\
f43a9e8cac3f"],

Cell["http://www.brucemo.com/compchess/programming/index.htm", "Text",
 CellChangeTimes->{
  3.860432184280446*^9},ExpressionUUID->"7ed8972b-fd96-4928-9230-\
fe5c90944c1d"],

Cell["https://rustic-chess.org/", "Text",
 CellChangeTimes->{
  3.8604322675910873`*^9},ExpressionUUID->"b49f3d5d-8da2-4153-b2ea-\
efe922388259"],

Cell["\<\
The classical approach to generating bitboard sliding piece attacks:\
\>", "Text",
 CellChangeTimes->{{3.8604418501139097`*^9, 
  3.860441873147403*^9}},ExpressionUUID->"f580064c-34c3-4d85-9cf1-\
1ee58b37e2ec"],

Cell["https://www.chessprogramming.org/Classical_Approach", "Text",
 CellChangeTimes->{
  3.8604418159596252`*^9},ExpressionUUID->"0b0cdfd4-942d-453e-8360-\
03a20b1eb6ae"],

Cell["https://www.chessprogramming.org/Aspiration_Windows", "Text",
 CellChangeTimes->{
  3.860452431767275*^9},ExpressionUUID->"ab8c3273-e0ba-4567-98f3-\
7fa810a21627"]
}, Closed]]
}, Open  ]]
},
WindowSize->{1139, 699},
WindowMargins->{{Automatic, 150}, {Automatic, 33}},
PrintingCopies->1,
PrintingPageRange->{1, Automatic},
FrontEndVersion->"13.0 for Mac OS X x86 (64-bit) (January 26, 2022)",
StyleDefinitions->"Default.nb",
ExpressionUUID->"748ca6ea-9ba3-4f71-9862-c07f40457921"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{}
*)
(*CellTagsIndex
CellTagsIndex->{}
*)
(*NotebookFileOutline
Notebook[{
Cell[CellGroupData[{
Cell[580, 22, 172, 3, 98, "Title",ExpressionUUID->"68add65e-cd56-44a1-ab5e-b6e8555e9ccf"],
Cell[755, 27, 156, 3, 35, "Text",ExpressionUUID->"1753ab05-e552-4dbb-bfcc-e61e835b9a85"],
Cell[914, 32, 356, 6, 35, "Text",ExpressionUUID->"2a41ac94-1596-45c7-9897-60fbec7990be"],
Cell[1273, 40, 970, 16, 81, "Text",ExpressionUUID->"cfe1bbba-1424-4947-9b20-291553ade1be"],
Cell[2246, 58, 108, 0, 35, "Text",ExpressionUUID->"0055e0fb-abc9-4009-a038-dd07907a5b5b"],
Cell[2357, 60, 865, 14, 58, "Text",ExpressionUUID->"02c10016-c601-4f91-865e-1befdb355207"],
Cell[3225, 76, 930, 15, 81, "Text",ExpressionUUID->"76cf1f93-5619-4684-80b9-9bb41b6fe571"],
Cell[4158, 93, 345, 7, 35, "Text",ExpressionUUID->"ea8f2cc8-dcb8-4c21-b24c-365a66e4e5ec"],
Cell[CellGroupData[{
Cell[4528, 104, 155, 3, 67, "Section",ExpressionUUID->"05a33c8f-42cb-4085-91ae-1e3f46174478"],
Cell[4686, 109, 148, 3, 35, "Text",ExpressionUUID->"7d59de6a-2206-47e3-8bdd-59cd49a7e330"]
}, Open  ]],
Cell[CellGroupData[{
Cell[4871, 117, 151, 3, 67, "Section",ExpressionUUID->"926d0580-5914-465a-8d4e-eaf7d189e9cd"],
Cell[5025, 122, 167, 3, 35, "Text",ExpressionUUID->"a9300752-47aa-451e-849a-49e49224424d"]
}, Open  ]],
Cell[CellGroupData[{
Cell[5229, 130, 155, 3, 67, "Section",ExpressionUUID->"77661812-1b6f-40d5-a28c-f6731f7a784b"],
Cell[5387, 135, 428, 8, 35, "Text",ExpressionUUID->"5381385f-b79f-481a-aa7d-3594da5b42cb"]
}, Open  ]],
Cell[CellGroupData[{
Cell[5852, 148, 275, 4, 67, "Section",ExpressionUUID->"21542e4b-72a9-42f3-8da1-d958097c6e8e"],
Cell[6130, 154, 172, 3, 35, "Text",ExpressionUUID->"26df83a3-cda7-4f1e-8c3b-4972c4026bec"],
Cell[6305, 159, 193, 4, 35, "Text",ExpressionUUID->"1b97f0bb-2666-45a4-bfa6-7b4618e5cf64"]
}, Open  ]],
Cell[CellGroupData[{
Cell[6535, 168, 171, 3, 67, "Section",ExpressionUUID->"629582e1-f628-4e68-908f-2a5fc56f0100"],
Cell[6709, 173, 180, 3, 35, "Text",ExpressionUUID->"06210a81-bd1b-453c-acc7-9b75da36b3b7"],
Cell[6892, 178, 146, 3, 35, "Text",ExpressionUUID->"5a9d6a2e-fd7d-4f7a-bf70-142aa8aa28c3"]
}, Open  ]],
Cell[CellGroupData[{
Cell[7075, 186, 165, 3, 67, "Section",ExpressionUUID->"a3d16acf-308a-4120-9b66-b2979cce2bfc"],
Cell[7243, 191, 321, 7, 35, "Text",ExpressionUUID->"651db410-1587-42f6-81ae-a045316a0d95"],
Cell[7567, 200, 176, 3, 35, "Text",ExpressionUUID->"b6fc4efa-9101-4bdb-a0e2-ee5e87eccafa"],
Cell[7746, 205, 467, 14, 242, "Text",ExpressionUUID->"fd95d833-95af-4249-b03e-24730f3208af"],
Cell[8216, 221, 224, 5, 35, "Text",ExpressionUUID->"471153b1-4585-481d-9211-e6b3accb0520"],
Cell[8443, 228, 193, 3, 35, "Text",ExpressionUUID->"ff8e303d-5002-4d50-987c-0eba128a6b0f"],
Cell[8639, 233, 189, 3, 35, "Text",ExpressionUUID->"88821641-8414-4003-8923-fd60a0635d3e"],
Cell[8831, 238, 329, 10, 104, "Text",ExpressionUUID->"21880b04-ce70-4749-84a1-9a8b6d89a1aa"],
Cell[9163, 250, 157, 3, 35, "Text",ExpressionUUID->"e462c5d3-3691-472c-b8b0-04b200438eb3"],
Cell[9323, 255, 232, 9, 104, "Text",ExpressionUUID->"8610c333-fb21-41db-a01d-d2a38810b054"],
Cell[9558, 266, 365, 8, 35, "Text",ExpressionUUID->"1548fa4b-b83b-4342-888e-b1f79937535f"],
Cell[9926, 276, 223, 4, 35, "Text",ExpressionUUID->"424b2180-3d5a-486e-a4eb-676a0b964f57"],
Cell[10152, 282, 298, 7, 35, "Text",ExpressionUUID->"491d58df-142b-45ee-a5a1-21f17387809c"],
Cell[10453, 291, 337, 7, 35, "Text",ExpressionUUID->"c2a21a82-f9c5-4924-9199-b5e4aa46bdce"],
Cell[10793, 300, 1883, 41, 679, "Text",ExpressionUUID->"1864e459-2edd-48c2-94ec-ee9733ef38ed"],
Cell[12679, 343, 548, 10, 58, "Text",ExpressionUUID->"efee58b3-aa1b-43f7-b0fa-879b542f0c84"],
Cell[13230, 355, 166, 3, 35, "Text",ExpressionUUID->"55881ed5-f810-4583-87e7-25d652699237"],
Cell[13399, 360, 590, 16, 288, "Text",ExpressionUUID->"2ce14ecc-f1da-453b-88d2-a0d9ca09ad07"],
Cell[13992, 378, 182, 3, 35, "Text",ExpressionUUID->"f2edca4a-6988-44b3-82df-05d6897f7174"],
Cell[14177, 383, 133, 3, 35, "Text",ExpressionUUID->"233d1292-c3b0-4645-a4f1-46576e3f7d19"],
Cell[14313, 388, 248, 6, 35, "Text",ExpressionUUID->"4fec85f3-926a-41b4-9404-7e8acb5eb5e2"],
Cell[14564, 396, 181, 3, 35, "Text",ExpressionUUID->"116af054-d2a4-49ba-8c08-8b933a608f1f"],
Cell[14748, 401, 167, 3, 35, "Text",ExpressionUUID->"d991bbac-14e8-4c98-ad1a-5244d964aa6f"],
Cell[14918, 406, 370, 8, 35, "Text",ExpressionUUID->"4e608162-03ac-4c4a-b8b4-31ea291f869a"],
Cell[15291, 416, 321, 14, 219, "Text",ExpressionUUID->"22d87535-f1a1-474c-b055-c4c1e7a27cfe"],
Cell[15615, 432, 508, 9, 58, "Text",ExpressionUUID->"db2a18ea-7328-485d-b80f-7da8f90cce76"],
Cell[16126, 443, 147, 3, 35, "Text",ExpressionUUID->"91a1a6b4-7b7f-4826-9f30-664385c431ad"],
Cell[16276, 448, 234, 5, 35, "Text",ExpressionUUID->"7b235dbd-1a18-4584-90b5-4a67f8ff34bb"],
Cell[16513, 455, 206, 3, 35, "Text",ExpressionUUID->"564c2d8f-178a-4bf6-8c42-f67627479fda"],
Cell[16722, 460, 261, 6, 35, "Text",ExpressionUUID->"3c65d667-bb1e-4549-9cf2-1f1b7614eb59"],
Cell[16986, 468, 380, 8, 58, "Text",ExpressionUUID->"ddab1ea6-0898-4374-9145-5ee9829d63b7"],
Cell[17369, 478, 162, 3, 35, "Text",ExpressionUUID->"43a04fbd-1089-4f48-a854-cd345bbf998d"],
Cell[17534, 483, 405, 6, 35, "Text",ExpressionUUID->"c97a2b0c-e24e-40f3-b495-e496ad75e824"],
Cell[17942, 491, 584, 10, 58, "Text",ExpressionUUID->"9d540e1b-dcd2-4eb5-a567-b486aa13a59b"],
Cell[18529, 503, 383, 6, 35, "Text",ExpressionUUID->"fa3185aa-1f2a-46c4-a8c0-e4b8bfc26482"]
}, Closed]],
Cell[CellGroupData[{
Cell[18949, 514, 163, 3, 53, "Section",ExpressionUUID->"007dd17b-4966-4b00-a9e6-9d2b36b2e326"],
Cell[19115, 519, 505, 22, 426, "Text",ExpressionUUID->"274a2cbd-3b26-4fdc-9680-21e7ba6fe606"],
Cell[19623, 543, 720, 26, 495, "Text",ExpressionUUID->"09c535e2-8769-4b8f-9dc4-e57e1d8ba5c6"],
Cell[20346, 571, 231, 4, 35, "Text",ExpressionUUID->"5dd29900-2178-4794-a5c6-e2a395d1f214"]
}, Closed]],
Cell[CellGroupData[{
Cell[20614, 580, 157, 3, 53, "Section",ExpressionUUID->"01de79f0-ee2b-4f79-9cdb-84afbb338bc7"],
Cell[20774, 585, 428, 8, 58, "Text",ExpressionUUID->"a76a72f2-6837-4fe0-aaa6-4e9cfa9b6bc6"],
Cell[21205, 595, 182, 3, 38, "CodeText",ExpressionUUID->"6c9637df-0a60-4fcc-8c61-66c05390565e"],
Cell[21390, 600, 201, 3, 35, "Text",ExpressionUUID->"13d919eb-0e9e-4117-96d2-74aba2575010"],
Cell[21594, 605, 483, 9, 80, "CodeText",ExpressionUUID->"b4d0c87a-553e-48f7-aa59-e9e5e469a4b7"],
Cell[22080, 616, 243, 6, 58, "Text",ExpressionUUID->"b6278e5b-9447-4916-8478-d5fb9d757d29"],
Cell[22326, 624, 328, 9, 122, "CodeText",ExpressionUUID->"c74477fd-461e-4981-adc7-7b76fde27b6f"],
Cell[22657, 635, 319, 7, 35, "Text",ExpressionUUID->"b72aacdc-4f07-40dc-a481-66615ccb511e"],
Cell[22979, 644, 182, 3, 35, "Text",ExpressionUUID->"3c54fbf9-6ddc-42e2-b2cc-045a67a09370"],
Cell[23164, 649, 485, 18, 311, "CodeText",ExpressionUUID->"54be1d98-79e3-424f-85e0-8e2b37622151"],
Cell[23652, 669, 191, 3, 35, "Text",ExpressionUUID->"8093f356-28b0-4ecc-8f7d-b12c7e750487"],
Cell[23846, 674, 644, 30, 563, "CodeText",ExpressionUUID->"47811b36-59e4-49b8-85b7-9cf5db18d31b"]
}, Closed]],
Cell[CellGroupData[{
Cell[24527, 709, 269, 4, 53, "Section",ExpressionUUID->"099baa15-68c2-4630-97a5-50d4978245ef"],
Cell[24799, 715, 386, 8, 58, "Text",ExpressionUUID->"d3269187-2ded-4d78-a9a9-a9f7df0b4eb2"],
Cell[25188, 725, 822, 41, 863, "Text",ExpressionUUID->"8edd3dc1-5a60-49bf-bfa3-4c0473fc0a7c"],
Cell[26013, 768, 196, 3, 35, "Text",ExpressionUUID->"419a1c84-eaf2-4e46-b734-329b64ea2eba"],
Cell[26212, 773, 185, 4, 35, "Text",ExpressionUUID->"8b66e3f0-4604-4fea-9081-2da541ae3d7c"],
Cell[26400, 779, 252, 7, 35, "Text",ExpressionUUID->"aa5516ec-298b-42e0-8bb5-21771bac0b63"],
Cell[26655, 788, 425, 9, 104, "Text",ExpressionUUID->"25988fd9-7fa8-445b-89b0-f14813bcbf1c"],
Cell[27083, 799, 273, 8, 104, "Text",ExpressionUUID->"8f45b66b-c68a-4c03-bc65-894e43ca5abe"],
Cell[27359, 809, 3378, 105, 2174, "Text",ExpressionUUID->"312f9d45-cf8d-4914-8fe6-e27f23195512"]
}, Closed]],
Cell[CellGroupData[{
Cell[30774, 919, 153, 3, 53, "Section",ExpressionUUID->"7142e7ba-2d53-47ad-9bda-73643e4981eb"],
Cell[30930, 924, 227, 4, 35, "Text",ExpressionUUID->"30666dfb-6699-4323-ab02-366209cc39d8"],
Cell[31160, 930, 1077, 36, 725, "Text",ExpressionUUID->"e9cf66e0-9cdd-425d-aebb-b096be5dc5d8"]
}, Closed]],
Cell[CellGroupData[{
Cell[32274, 971, 158, 3, 53, "Section",ExpressionUUID->"f54ba241-0067-4000-83ae-71637fc92a96"],
Cell[32435, 976, 666, 14, 150, "Text",ExpressionUUID->"edfb31a7-1877-4ae5-abd7-b9a42f9d7725"],
Cell[33104, 992, 1117, 37, 771, "Text",ExpressionUUID->"cd56be02-11bf-49d2-be0d-93320df76d22"]
}, Closed]],
Cell[CellGroupData[{
Cell[34258, 1034, 169, 3, 53, "Section",ExpressionUUID->"fee74736-564d-432a-925b-e63545d91727"],
Cell[34430, 1039, 270, 6, 35, "Text",ExpressionUUID->"ab06c854-0591-48b9-bd75-61ba70d47e6b"],
Cell[34703, 1047, 177, 6, 58, "Text",ExpressionUUID->"af99a7f9-1cdc-4bb9-a999-83452cecc552"],
Cell[34883, 1055, 460, 19, 357, "Text",ExpressionUUID->"5cf6e154-aafc-4c98-9f65-3d9892235811"]
}, Closed]],
Cell[CellGroupData[{
Cell[35380, 1079, 159, 3, 53, "Section",ExpressionUUID->"e9009682-d816-4caf-a608-2fcd0062f3c4"],
Cell[35542, 1084, 341, 8, 104, "Text",ExpressionUUID->"e92b5067-d1cd-4150-bc04-4998c77b75c4"],
Cell[35886, 1094, 825, 16, 150, "Text",ExpressionUUID->"d26ce50b-8f9d-405a-af3d-27bacd97ef4a"],
Cell[36714, 1112, 354, 7, 58, "Text",ExpressionUUID->"12f9dbed-49a4-4f40-a38b-80aab6672dc7"],
Cell[37071, 1121, 4013, 156, 3255, "Text",ExpressionUUID->"8ae1ea75-331e-4e77-856f-cdfd446b107a"]
}, Closed]],
Cell[CellGroupData[{
Cell[41121, 1282, 159, 3, 53, "Section",ExpressionUUID->"62acae9b-452d-4f1d-bd98-21b43fe66dd1"],
Cell[41283, 1287, 183, 8, 104, "Text",ExpressionUUID->"9c64c289-6049-45ea-b345-e3677a40535d"],
Cell[41469, 1297, 505, 10, 173, "Text",ExpressionUUID->"a9189b2c-0e9d-456c-992d-8c8e45acdbf8"],
Cell[41977, 1309, 282, 6, 35, "Text",ExpressionUUID->"4856270c-9e28-46b2-af16-9783439992fd"],
Cell[42262, 1317, 450, 12, 150, "Text",ExpressionUUID->"0b80b2fd-5d82-4989-a897-5de88e7a99bd"],
Cell[42715, 1331, 272, 8, 81, "Text",ExpressionUUID->"2c0e7b11-70f4-460d-b572-0760666fc4a8"],
Cell[42990, 1341, 215, 4, 35, "Text",ExpressionUUID->"afa46df9-e956-452d-bd04-284335ae3fe0"],
Cell[43208, 1347, 226, 7, 58, "Text",ExpressionUUID->"e7399bed-e76b-4091-80ce-fc46b561bfd3"]
}, Closed]],
Cell[CellGroupData[{
Cell[43471, 1359, 170, 3, 53, "Section",ExpressionUUID->"a7fd6c14-d30d-4314-b4cf-165eb8174a52"],
Cell[43644, 1364, 252, 6, 35, "Text",ExpressionUUID->"beaffe02-f4af-461f-b344-0de074bc0e7f"],
Cell[43899, 1372, 343, 16, 288, "Text",ExpressionUUID->"a4d77d28-cb05-449d-8085-d9a671b0952a"],
Cell[44245, 1390, 222, 4, 35, "Text",ExpressionUUID->"458f9c3e-5661-4fd0-abc4-adcd57b04fac"],
Cell[44470, 1396, 933, 37, 702, "Text",ExpressionUUID->"865e1413-996d-411b-afcf-abbaee269e32"]
}, Closed]],
Cell[CellGroupData[{
Cell[45440, 1438, 161, 3, 53, "Section",ExpressionUUID->"0131a07b-0bdb-4b5f-ad2f-eb5c30ca4e12"],
Cell[45604, 1443, 12409, 385, 7648, "Text",ExpressionUUID->"7044cb7b-609c-4537-b0a5-0ee12069edcc"],
Cell[58016, 1830, 408, 9, 35, "Text",ExpressionUUID->"00f3ea2b-557f-4cd3-a5f9-2913b3dbc873"],
Cell[58427, 1841, 5974, 190, 3623, "Text",ExpressionUUID->"9f18c4f7-639a-4ddc-bed3-83582ce9eabc"]
}, Closed]],
Cell[CellGroupData[{
Cell[64438, 2036, 162, 3, 53, "Section",ExpressionUUID->"2e32f6da-b4ac-4620-baf4-e7adad53e115"],
Cell[64603, 2041, 386, 8, 104, "Text",ExpressionUUID->"ce2f5248-5578-4531-b139-15fd60b9116f"],
Cell[64992, 2051, 496, 15, 242, "Text",ExpressionUUID->"7b498356-07f1-4e69-bf8b-0b19a0a3cfee"],
Cell[65491, 2068, 966, 44, 909, "Text",ExpressionUUID->"c7a580c1-15b9-4884-91bd-b39978d2a884"],
Cell[66460, 2114, 694, 31, 610, "Text",ExpressionUUID->"29ad9cbc-41a4-4133-bc02-d48c77cc5be2"],
Cell[67157, 2147, 798, 31, 610, "Text",ExpressionUUID->"fec1540b-71ef-4a9a-8bdd-2c817aabf0bf"],
Cell[67958, 2180, 2228, 101, 2197, "Text",ExpressionUUID->"32ed5fbe-a0d8-41f6-a3e1-e4733a1a838d"],
Cell[70189, 2283, 1535, 62, 1300, "Text",ExpressionUUID->"4c6e61c0-a1af-4674-9d73-9c4cd4b98a3e"]
}, Closed]],
Cell[CellGroupData[{
Cell[71761, 2350, 150, 3, 53, "Section",ExpressionUUID->"c0a97d02-f196-4b90-84d9-889569a46f4f"],
Cell[71914, 2355, 213, 5, 35, "Text",ExpressionUUID->"bbc95a56-93bf-4e21-b8aa-30c3ada3cadf"],
Cell[72130, 2362, 155, 3, 35, "Text",ExpressionUUID->"768182dd-1e04-4877-a043-5ce17978993d"],
Cell[72288, 2367, 616, 28, 541, "Text",ExpressionUUID->"882d443d-c4c9-4012-a17d-304aa4bc50b4"],
Cell[72907, 2397, 940, 33, 633, "Text",ExpressionUUID->"fdd6fdcb-a2d7-465a-b6bf-31c37ae62385"]
}, Closed]],
Cell[CellGroupData[{
Cell[73884, 2435, 228, 4, 53, "Section",ExpressionUUID->"de0b4088-b7f1-4c7f-82b1-e58217b43293"],
Cell[74115, 2441, 136, 3, 35, "Text",ExpressionUUID->"2ac1cc93-42bd-4449-b826-e4f1433bc021"],
Cell[74254, 2446, 2596, 74, 1323, "Text",ExpressionUUID->"285f1bbc-65ae-4962-9f72-3b73271f4a0d"]
}, Closed]],
Cell[CellGroupData[{
Cell[76887, 2525, 167, 3, 53, "Section",ExpressionUUID->"758dca74-3a8b-4026-adfc-e158d74ca387"],
Cell[77057, 2530, 395, 16, 265, "Text",ExpressionUUID->"8555d2fe-a816-43d2-8226-db0d259a9a3d"]
}, Closed]],
Cell[CellGroupData[{
Cell[77489, 2551, 176, 3, 53, "Section",ExpressionUUID->"fd0386ea-2d9e-4a6f-948a-a1b64f6dcde6"],
Cell[77668, 2556, 174, 7, 81, "Text",ExpressionUUID->"28dceec8-c7c3-4bec-bc6a-5ce0201931c6"]
}, Closed]],
Cell[CellGroupData[{
Cell[77879, 2568, 168, 3, 53, "Section",ExpressionUUID->"1d275da5-2e04-44dd-adda-166229729898"],
Cell[78050, 2573, 360, 8, 35, "Text",ExpressionUUID->"d214428c-7f14-4708-a5fc-c77666bdbc70"],
Cell[78413, 2583, 170, 3, 35, "Text",ExpressionUUID->"59bac90e-2d98-406a-8aad-86c6ece2da2e"],
Cell[78586, 2588, 476, 9, 58, "Text",ExpressionUUID->"f819dd95-0928-4cd0-a376-8031966cf926"],
Cell[79065, 2599, 213, 8, 101, "CodeText",ExpressionUUID->"c891e781-ab9b-4c5d-905b-0b6f93bd30fa"],
Cell[79281, 2609, 617, 10, 81, "Text",ExpressionUUID->"5bebba1a-805f-4adf-84cf-e099243b8d6c"],
Cell[79901, 2621, 228, 8, 101, "CodeText",ExpressionUUID->"d6b8b547-f07f-448a-b728-ecda99c3eb67"],
Cell[80132, 2631, 372, 7, 35, "Text",ExpressionUUID->"c1cc528b-e9bd-40c5-b8c4-f259f0411192"],
Cell[80507, 2640, 143, 3, 38, "CodeText",ExpressionUUID->"fec65ea4-1684-4a38-a8cc-3d263fda9a25"],
Cell[80653, 2645, 233, 4, 35, "Text",ExpressionUUID->"51eea0b3-4734-4ff6-aaef-63d71025911d"],
Cell[80889, 2651, 233, 4, 38, "CodeText",ExpressionUUID->"d6a14e81-4260-4c19-9c56-4ad8b1e5a896"],
Cell[81125, 2657, 238, 4, 35, "Text",ExpressionUUID->"31c5664c-5644-4a92-b15d-32096e5235b0"],
Cell[81366, 2663, 1146, 23, 248, "CodeText",ExpressionUUID->"bb57044b-08a6-4d84-a743-427f94c28742"],
Cell[82515, 2688, 338, 7, 35, "Text",ExpressionUUID->"3ce625b8-22fc-43b8-80a2-eace274520f3"],
Cell[82856, 2697, 807, 20, 227, "CodeText",ExpressionUUID->"1fb1021d-1663-4932-8528-9a9711adc104"],
Cell[83666, 2719, 182, 3, 35, "Text",ExpressionUUID->"88e80914-6f1c-4841-9d22-b664263ef5df"],
Cell[83851, 2724, 172, 3, 38, "CodeText",ExpressionUUID->"91fef5c9-7bed-48f6-b500-b2baf50839cc"],
Cell[84026, 2729, 299, 7, 35, "Text",ExpressionUUID->"36bc2336-2940-4a5a-93f3-65f097700cc3"],
Cell[84328, 2738, 677, 16, 164, "CodeText",ExpressionUUID->"f692e4a9-f839-48ce-9ba0-c5030a9223f9"],
Cell[85008, 2756, 594, 18, 227, "CodeText",ExpressionUUID->"087766be-4ed2-49e4-be1b-c384cb5f4244"],
Cell[85605, 2776, 319, 7, 58, "Text",ExpressionUUID->"ae7d0a76-bf08-4cfd-be5e-f793a4577b7f"],
Cell[85927, 2785, 159, 3, 35, "Text",ExpressionUUID->"11583d22-bb48-4697-8359-e126aec6b464"],
Cell[86089, 2790, 168, 3, 38, "CodeText",ExpressionUUID->"436a00a9-2305-41dd-9985-551bc5780415"],
Cell[86260, 2795, 484, 9, 58, "Text",ExpressionUUID->"5358a2c8-e260-4433-8148-5a0eb497ede6"],
Cell[86747, 2806, 585, 22, 395, "CodeText",ExpressionUUID->"d24d74c9-df5f-487e-92c9-653188cb2ecb"],
Cell[87335, 2830, 268, 6, 35, "Text",ExpressionUUID->"17771134-7b21-42b6-b082-02b701b7800b"],
Cell[87606, 2838, 309, 7, 35, "Text",ExpressionUUID->"b7b8e206-c870-4d55-9fa4-74e15aa1cf11"],
Cell[87918, 2847, 635, 29, 521, "CodeText",ExpressionUUID->"4c766da8-9803-465f-8da2-74607422e783"]
}, Closed]],
Cell[CellGroupData[{
Cell[88590, 2881, 166, 3, 53, "Section",ExpressionUUID->"90954c09-51c7-473b-a2c5-f6d3695ec7d4"],
Cell[88759, 2886, 194, 3, 35, "Text",ExpressionUUID->"5e057804-94eb-4917-ab49-f2e8bdb19b9d"],
Cell[88956, 2891, 329, 21, 403, "Text",ExpressionUUID->"f3357b39-f3df-4e01-a53e-c79976a8b48d"]
}, Closed]],
Cell[CellGroupData[{
Cell[89322, 2917, 157, 3, 53, "Section",ExpressionUUID->"613e6538-7d74-4f8b-93f2-0f921b519675"],
Cell[89482, 2922, 8251, 256, 5601, "Text",ExpressionUUID->"57f76675-1fd1-4aad-b1a4-bf77c0b1d1fb"]
}, Closed]],
Cell[CellGroupData[{
Cell[97770, 3183, 163, 3, 53, "Section",ExpressionUUID->"a6103b41-8de3-412e-9e23-442b33cbb60f"],
Cell[97936, 3188, 794, 31, 587, "Text",ExpressionUUID->"f3599389-46d2-490b-80ea-6df0f609792a"]
}, Closed]],
Cell[CellGroupData[{
Cell[98767, 3224, 237, 4, 53, "Section",ExpressionUUID->"a1238f50-0188-43aa-834c-58d5979cf434"],
Cell[99007, 3230, 339, 17, 265, "Text",ExpressionUUID->"e63f5e97-5d6b-48fd-b0dc-857fc486355b"],
Cell[99349, 3249, 840, 14, 127, "Text",ExpressionUUID->"38537598-d97d-4022-816c-d4fb6f7bba89"],
Cell[100192, 3265, 260, 6, 35, "Text",ExpressionUUID->"61375a86-9a91-4bf7-8c4c-6897031215ec"],
Cell[100455, 3273, 1617, 53, 1024, "Text",ExpressionUUID->"a9a4214c-d293-423e-9625-32ade8059ad5"]
}, Closed]],
Cell[CellGroupData[{
Cell[102109, 3331, 178, 3, 53, "Section",ExpressionUUID->"93d0f366-7324-40e2-ac16-0b4a3bd2d675"],
Cell[102290, 3336, 427, 16, 242, "Text",ExpressionUUID->"7e6eb3e2-11c7-495e-88ba-0197cadcaf63"],
Cell[102720, 3354, 309, 8, 58, "Text",ExpressionUUID->"0e689f05-5197-4c8e-9fc7-30973c602135"],
Cell[103032, 3364, 286, 9, 104, "Text",ExpressionUUID->"b5a1096e-0eec-42a7-92d2-8a3c96106e62"],
Cell[103321, 3375, 246, 7, 58, "Text",ExpressionUUID->"893273e5-4481-4d4b-a99f-4d4427cbbed6"],
Cell[103570, 3384, 455, 15, 219, "Text",ExpressionUUID->"6b4b8112-04b4-4fdd-9e62-03c65cf7988e"],
Cell[104028, 3401, 175, 3, 35, "Text",ExpressionUUID->"179d2ae4-b999-4f2e-a32f-0e2147427c96"]
}, Closed]],
Cell[CellGroupData[{
Cell[104240, 3409, 151, 3, 53, "Section",ExpressionUUID->"9886cc69-3c76-4ddd-ad34-7314c974720d"],
Cell[104394, 3414, 418, 8, 58, "Text",ExpressionUUID->"cf639556-13d8-4d08-b61a-a787343be073"],
Cell[104815, 3424, 593, 21, 403, "Text",ExpressionUUID->"0a4bac8e-12da-450d-81f3-b7f6bf714e67"]
}, Closed]],
Cell[CellGroupData[{
Cell[105445, 3450, 181, 3, 53, "Section",ExpressionUUID->"5b6de16b-202c-4cdd-89a9-b38c96260d7a"],
Cell[CellGroupData[{
Cell[105651, 3457, 174, 2, 54, "Subsection",ExpressionUUID->"2b4e2bab-0586-4d2a-8c8d-5aebf1dd2d23"],
Cell[CellGroupData[{
Cell[105850, 3463, 157, 3, 45, "Subsubsection",ExpressionUUID->"681e10a5-16f2-4e6c-a090-387d78754885"],
Cell[106010, 3468, 1023, 16, 104, "Text",ExpressionUUID->"fa808696-d1bc-4863-ba27-906572ad6df6"],
Cell[CellGroupData[{
Cell[107058, 3488, 1281, 35, 73, "Input",ExpressionUUID->"19225840-f28d-481c-b74f-93683e13c3b0",
 CellID->1524298092],
Cell[108342, 3525, 14793, 252, 284, 2234, 44, "CachedBoxData", "BoxData", "Output",ExpressionUUID->"bd23fe48-9478-4dd8-a2dc-32f53a65c969"]
}, {2}]],
Cell[123147, 3780, 166, 3, 35, "Text",ExpressionUUID->"8b5de160-cd45-4610-8fd0-f97e8b5515a3"],
Cell[CellGroupData[{
Cell[123338, 3787, 1488, 40, 73, "Input",ExpressionUUID->"b7c96bff-2e08-4608-9db5-9a4537fd3081",
 CellID->568577340],
Cell[124829, 3829, 2611, 53, 291, "Output",ExpressionUUID->"82ca5c72-34ac-4230-8718-204606f7cf4d"]
}, {2}]]
}, Open  ]],
Cell[CellGroupData[{
Cell[127486, 3888, 364, 6, 45, "Subsubsection",ExpressionUUID->"68c99194-72cb-4e0c-96c9-5194ae32dca9"],
Cell[CellGroupData[{
Cell[127875, 3898, 1996, 55, 115, "Input",ExpressionUUID->"d963b083-0404-43e0-a8df-e787996288e8",
 CellID->1330103967],
Cell[129874, 3955, 3863, 80, 198, "Output",ExpressionUUID->"3dde7012-1d8d-4ac7-ae94-6010a1c9a16b"]
}, {2}]],
Cell[133749, 4038, 875, 19, 104, "Text",ExpressionUUID->"5e79cf24-f2aa-4782-afd1-72152c12ca3f"],
Cell[CellGroupData[{
Cell[134649, 4061, 2019, 53, 115, "Input",ExpressionUUID->"25ba39bc-1c55-42bc-8f8f-b4175e7b98c6",
 CellID->151803337],
Cell[136671, 4116, 3891, 79, 198, "Output",ExpressionUUID->"d429d03d-d969-414b-8323-12a4f562e5ff"]
}, {2}]],
Cell[140574, 4198, 318, 7, 58, "Text",ExpressionUUID->"8661ce73-faa3-41b3-aa82-f92c50a12adf"],
Cell[CellGroupData[{
Cell[140917, 4209, 2131, 56, 115, "Input",ExpressionUUID->"af3984e7-6e06-472a-9385-22be3b7daa9c",
 CellID->1011930940],
Cell[143051, 4267, 4007, 83, 206, "Output",ExpressionUUID->"6c848181-49ac-4150-b6ec-f9234875a73f"]
}, {2}]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[147116, 4357, 234, 3, 54, "Subsection",ExpressionUUID->"9f42e75b-0077-42c6-9953-2ca442cd0bea"],
Cell[147353, 4362, 967, 15, 104, "Text",ExpressionUUID->"01f9cf52-501c-4c14-819c-71e39a2fb22b"],
Cell[CellGroupData[{
Cell[148345, 4381, 2022, 49, 94, "Input",ExpressionUUID->"9ccfef1d-93dd-402a-b532-6ab4bc59d856",
 CellID->213611487],
Cell[150370, 4432, 3198, 64, 209, "Output",ExpressionUUID->"4d660d3f-e5ce-46a9-8ac6-27d84a5b2341"]
}, {2}]]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[153626, 4503, 176, 3, 53, "Section",ExpressionUUID->"656a5818-18c1-4fe6-b3e3-4b1c773def78"],
Cell[153805, 4508, 2919, 91, 1668, "Text",ExpressionUUID->"bd9a8585-2d95-4d7a-b3ef-c5cf0a74694c"]
}, Open  ]],
Cell[CellGroupData[{
Cell[156761, 4604, 266, 4, 67, "Section",ExpressionUUID->"2c6937d6-41ed-4f4a-acaa-0de0c86f8e53"],
Cell[157030, 4610, 279, 8, 58, "Text",ExpressionUUID->"29cd0348-d809-4bef-aaa1-f67db9f569ef"],
Cell[157312, 4620, 250, 5, 35, "Text",ExpressionUUID->"46adc27c-6e2f-458e-9514-bdec25771b00"],
Cell[157565, 4627, 460, 14, 196, "Text",ExpressionUUID->"83c365d6-5951-497e-94c7-81a872a46590"],
Cell[158028, 4643, 2679, 112, 2358, "Text",ExpressionUUID->"4ef751d8-9027-42db-8068-919f7ae1052a"]
}, Open  ]],
Cell[160722, 4758, 196, 3, 67, "Section",ExpressionUUID->"1abb9ea8-eb07-47ee-9395-3ab06cb919f9"],
Cell[CellGroupData[{
Cell[160943, 4765, 193, 3, 53, "Section",ExpressionUUID->"fc910055-988b-4279-ac21-f419bf32032b"],
Cell[161139, 4770, 1905, 86, 1852, "Text",ExpressionUUID->"03024f77-c94a-4c55-b00c-88b4c3917539"]
}, Closed]],
Cell[CellGroupData[{
Cell[163081, 4861, 159, 3, 53, "Section",ExpressionUUID->"bbcce15d-519b-491c-b250-0c917b67b3ab"],
Cell[163243, 4866, 206, 4, 35, "Text",ExpressionUUID->"8f0ab1ec-a568-457c-826c-c3f4cb705b7b"],
Cell[163452, 4872, 240, 4, 35, "Text",ExpressionUUID->"478882c1-3e83-4c95-93bf-f7edcb3296bb"]
}, Closed]],
Cell[CellGroupData[{
Cell[163729, 4881, 229, 4, 53, "Section",ExpressionUUID->"fe0b68d3-690e-4e1d-ac33-75ca31034866"],
Cell[163961, 4887, 4949, 174, 3370, "Text",ExpressionUUID->"26548146-8a45-4892-8884-dc19a4d349bf"]
}, Closed]],
Cell[CellGroupData[{
Cell[168947, 5066, 154, 3, 53, "Section",ExpressionUUID->"9b47d032-c2a5-4f04-b1bf-0ff6784d14c1"],
Cell[169104, 5071, 1353, 52, 1047, "Text",ExpressionUUID->"c711b281-cb7b-4b22-a534-98100673b87d"]
}, Closed]],
Cell[CellGroupData[{
Cell[170494, 5128, 149, 3, 53, "Section",ExpressionUUID->"bed50d65-7655-4b16-9524-62c9610da330"],
Cell[170646, 5133, 1603, 65, 1323, "Text",ExpressionUUID->"9f241d94-3c96-4f02-9f0b-2c8a55ce7848"]
}, Closed]],
Cell[CellGroupData[{
Cell[172286, 5203, 166, 3, 53, "Section",ExpressionUUID->"4916af9e-3078-4fc0-92dd-e4e804e1584a"],
Cell[CellGroupData[{
Cell[172477, 5210, 226, 4, 54, "Subsection",ExpressionUUID->"8595eb4b-78f4-4e9e-847f-e1cb4e942e4b"],
Cell[172706, 5216, 690, 12, 81, "Text",ExpressionUUID->"68336e0c-83e9-4334-835f-d5a9a9233eab"]
}, Open  ]],
Cell[CellGroupData[{
Cell[173433, 5233, 235, 4, 54, "Subsection",ExpressionUUID->"bac28685-2a29-45b4-9abd-a1c270c0251e"],
Cell[173671, 5239, 184, 3, 35, "Text",ExpressionUUID->"944959ac-1f44-4832-8930-92298140a268"]
}, Open  ]],
Cell[CellGroupData[{
Cell[173892, 5247, 384, 7, 81, "Subsection",ExpressionUUID->"971bc7e4-7c6c-4c63-b7b5-def750e2774e"],
Cell[174279, 5256, 163, 3, 35, "Text",ExpressionUUID->"5e6e6102-973f-4753-85d5-d8d850b312cc"],
Cell[174445, 5261, 253, 6, 35, "Text",ExpressionUUID->"2698d452-a16a-44ef-9e8d-65d571b4278f"],
Cell[174701, 5269, 1232, 39, 702, "Text",ExpressionUUID->"e7ff9d50-2a0c-4a4d-96f9-39b87ae1211e"]
}, Open  ]],
Cell[CellGroupData[{
Cell[175970, 5313, 165, 3, 54, "Subsection",ExpressionUUID->"46e3bddf-4551-44ac-a0fd-2a6cbbc413d7"],
Cell[CellGroupData[{
Cell[176160, 5320, 297, 7, 45, "Subsubsection",ExpressionUUID->"172ebfae-91d7-4d11-90e1-86666024a8f4"],
Cell[176460, 5329, 1115, 20, 242, "Text",ExpressionUUID->"4691ebc9-7595-47e1-9c34-bd7acabf26f7"]
}, Open  ]],
Cell[CellGroupData[{
Cell[177612, 5354, 301, 7, 45, "Subsubsection",ExpressionUUID->"bf082fb3-b3b1-4d98-82de-0512ee4a2867"],
Cell[177916, 5363, 4176, 64, 771, "Text",ExpressionUUID->"09a00537-4bb6-4e35-8526-b1739895ee71"]
}, Open  ]]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[182153, 5434, 222, 4, 53, "Section",ExpressionUUID->"8180b180-3534-4762-91ff-7b4051a399e7"],
Cell[182378, 5440, 589, 11, 81, "Text",ExpressionUUID->"d6c7f6c4-916d-48e3-b20f-b90f0b0e9711"]
}, Closed]],
Cell[CellGroupData[{
Cell[183004, 5456, 155, 3, 53, "Section",ExpressionUUID->"e5dd233d-d827-4789-bf8c-f43a9e8cac3f"],
Cell[183162, 5461, 172, 3, 35, "Text",ExpressionUUID->"7ed8972b-fd96-4928-9230-fe5c90944c1d"],
Cell[183337, 5466, 145, 3, 35, "Text",ExpressionUUID->"b49f3d5d-8da2-4153-b2ea-efe922388259"],
Cell[183485, 5471, 220, 5, 35, "Text",ExpressionUUID->"f580064c-34c3-4d85-9cf1-1ee58b37e2ec"],
Cell[183708, 5478, 171, 3, 35, "Text",ExpressionUUID->"0b0cdfd4-942d-453e-8360-03a20b1eb6ae"],
Cell[183882, 5483, 169, 3, 35, "Text",ExpressionUUID->"ab8c3273-e0ba-4567-98f3-7fa810a21627"]
}, Closed]]
}, Open  ]]
}
]
*)
